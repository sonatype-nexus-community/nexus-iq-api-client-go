/*
Sonatype Lifecycle Public REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.182.0-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sonatypeiq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PolicyEvaluationAPIService PolicyEvaluationAPI service
type PolicyEvaluationAPIService service

type ApiEvaluateComponentsRequest struct {
	ctx context.Context
	ApiService *PolicyEvaluationAPIService
	applicationId string
	apiComponentEvaluationRequestDTOV2 *ApiComponentEvaluationRequestDTOV2
}

// The request JSON should contain component coordinates or the hash (SHA1) for each component. You can provide the packageURL instead of component information or hash.
func (r ApiEvaluateComponentsRequest) ApiComponentEvaluationRequestDTOV2(apiComponentEvaluationRequestDTOV2 ApiComponentEvaluationRequestDTOV2) ApiEvaluateComponentsRequest {
	r.apiComponentEvaluationRequestDTOV2 = &apiComponentEvaluationRequestDTOV2
	return r
}

func (r ApiEvaluateComponentsRequest) Execute() (*ApiComponentEvaluationTicketDTOV2, *http.Response, error) {
	return r.ApiService.EvaluateComponentsExecute(r)
}

/*
EvaluateComponents Method for EvaluateComponents

Use this method to request a component evaluation. This is step 1 of the 2 step policy evaluation for components process.

Permissions Required: Evaluate Components

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId Enter the internal applicationId. Use the Applications REST API to retrieve the internal applicationId.
 @return ApiEvaluateComponentsRequest
*/
func (a *PolicyEvaluationAPIService) EvaluateComponents(ctx context.Context, applicationId string) ApiEvaluateComponentsRequest {
	return ApiEvaluateComponentsRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return ApiComponentEvaluationTicketDTOV2
func (a *PolicyEvaluationAPIService) EvaluateComponentsExecute(r ApiEvaluateComponentsRequest) (*ApiComponentEvaluationTicketDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiComponentEvaluationTicketDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyEvaluationAPIService.EvaluateComponents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/evaluation/applications/{applicationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiComponentEvaluationRequestDTOV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEvaluateSourceControlRequest struct {
	ctx context.Context
	ApiService *PolicyEvaluationAPIService
	applicationId string
	apiSourceControlEvaluationRequestDTO *ApiSourceControlEvaluationRequestDTO
}

// The request JSON should include the 1. branch name (name of the target branch in the source control repository, 2. stageId (recommended values are &#39;develop&#39; for feature branches, and &#39;source&#39; for default branches. Other stageIds that can be used are &#39;build&#39;, &#39;stage-release&#39;, &#39;release&#39;, &#39;operate&#39; but are not recommended), 3. scanTargets (optional, specify one or more paths inside the repository. If not specified, the entire repository will be evaluated by default). Ensure that the repository paths are not relative and do not contain &#39;../&#39; or &#39;..\\&#39;.
func (r ApiEvaluateSourceControlRequest) ApiSourceControlEvaluationRequestDTO(apiSourceControlEvaluationRequestDTO ApiSourceControlEvaluationRequestDTO) ApiEvaluateSourceControlRequest {
	r.apiSourceControlEvaluationRequestDTO = &apiSourceControlEvaluationRequestDTO
	return r
}

func (r ApiEvaluateSourceControlRequest) Execute() (*ApiApplicationEvaluationStatusDTOV2, *http.Response, error) {
	return r.ApiService.EvaluateSourceControlExecute(r)
}

/*
EvaluateSourceControl Method for EvaluateSourceControl

Use this method to request a source control evaluation for a specific application. This is step 1 of the 2 step source control evaluation process. 

Permissions Required: Evaluate Applications

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId Enter the internal applicationId. Use the Applications REST API to retrieve the internal applicationId.
 @return ApiEvaluateSourceControlRequest
*/
func (a *PolicyEvaluationAPIService) EvaluateSourceControl(ctx context.Context, applicationId string) ApiEvaluateSourceControlRequest {
	return ApiEvaluateSourceControlRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return ApiApplicationEvaluationStatusDTOV2
func (a *PolicyEvaluationAPIService) EvaluateSourceControlExecute(r ApiEvaluateSourceControlRequest) (*ApiApplicationEvaluationStatusDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiApplicationEvaluationStatusDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyEvaluationAPIService.EvaluateSourceControl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/evaluation/applications/{applicationId}/sourceControlEvaluation"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiSourceControlEvaluationRequestDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationEvaluationStatusRequest struct {
	ctx context.Context
	ApiService *PolicyEvaluationAPIService
	applicationId string
	statusId string
}

func (r ApiGetApplicationEvaluationStatusRequest) Execute() (*ApiApplicationEvaluationResultDTOV2, *http.Response, error) {
	return r.ApiService.GetApplicationEvaluationStatusExecute(r)
}

/*
GetApplicationEvaluationStatus Method for GetApplicationEvaluationStatus

This is step 2 of the policy evaluation process. Use the statusUrl obtained from the POST response for the corresponding applicationId. 

Permissions Required: Evaluate Applications

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId Enter the applicationId, for the which policy evaluation was requested.
 @param statusId Enter the statusId value obtained as response of the POST call in step 1.
 @return ApiGetApplicationEvaluationStatusRequest
*/
func (a *PolicyEvaluationAPIService) GetApplicationEvaluationStatus(ctx context.Context, applicationId string, statusId string) ApiGetApplicationEvaluationStatusRequest {
	return ApiGetApplicationEvaluationStatusRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		statusId: statusId,
	}
}

// Execute executes the request
//  @return ApiApplicationEvaluationResultDTOV2
func (a *PolicyEvaluationAPIService) GetApplicationEvaluationStatusExecute(r ApiGetApplicationEvaluationStatusRequest) (*ApiApplicationEvaluationResultDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiApplicationEvaluationResultDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyEvaluationAPIService.GetApplicationEvaluationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/evaluation/applications/{applicationId}/status/{statusId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statusId"+"}", url.PathEscape(parameterValueToString(r.statusId, "statusId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComponentEvaluationRequest struct {
	ctx context.Context
	ApiService *PolicyEvaluationAPIService
	applicationId string
	resultId string
}

func (r ApiGetComponentEvaluationRequest) Execute() (*ApiComponentEvaluationResultDTOV2, *http.Response, error) {
	return r.ApiService.GetComponentEvaluationExecute(r)
}

/*
GetComponentEvaluation Method for GetComponentEvaluation

This is step 2 of the policy evaluation process for components. Use the resultId obtained from the POST response for the corresponding applicationId. 

Permissions Required: Evaluate Components 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId Enter the internal applicationId (same as that sent in the POST request (step 1))
 @param resultId Enter the resultId obtained from the POST response (step 1) used for component evaluation.
 @return ApiGetComponentEvaluationRequest
*/
func (a *PolicyEvaluationAPIService) GetComponentEvaluation(ctx context.Context, applicationId string, resultId string) ApiGetComponentEvaluationRequest {
	return ApiGetComponentEvaluationRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		resultId: resultId,
	}
}

// Execute executes the request
//  @return ApiComponentEvaluationResultDTOV2
func (a *PolicyEvaluationAPIService) GetComponentEvaluationExecute(r ApiGetComponentEvaluationRequest) (*ApiComponentEvaluationResultDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiComponentEvaluationResultDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyEvaluationAPIService.GetComponentEvaluation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/evaluation/applications/{applicationId}/results/{resultId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resultId"+"}", url.PathEscape(parameterValueToString(r.resultId, "resultId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPromoteScanRequest struct {
	ctx context.Context
	ApiService *PolicyEvaluationAPIService
	applicationId string
	apiPromoteScanRequestDTOV2 *ApiPromoteScanRequestDTOV2
}

// You can provide either the scanId (reportId) of the previous scan OR the source stageId (possible values are &#39;build&#39;, &#39;stage-release&#39;, &#39;release&#39; or &#39;operate&#39;). When using the stageId, the latest scanId for the application will be used. Enter the targetStageId for the new stage you want your scan to be promoted to (possible values are &#39;build&#39;, &#39;stage-release&#39;, &#39;release&#39; or &#39;operate&#39;). Using the same value for source and target stage will resubmit the latest scan report.
func (r ApiPromoteScanRequest) ApiPromoteScanRequestDTOV2(apiPromoteScanRequestDTOV2 ApiPromoteScanRequestDTOV2) ApiPromoteScanRequest {
	r.apiPromoteScanRequestDTOV2 = &apiPromoteScanRequestDTOV2
	return r
}

func (r ApiPromoteScanRequest) Execute() (*ApiApplicationEvaluationStatusDTOV2, *http.Response, error) {
	return r.ApiService.PromoteScanExecute(r)
}

/*
PromoteScan Method for PromoteScan

Use this method to rescan older scans. This is done when the binaries of a previous build are now moving to a new stage in the production pipeline. Using this method, you can avoid rebuilding the application and reuse the scan metadata at the newer stage. This new evaluation will evaluate the most recent security and license data against your current policies. 

Permissions Required: Evaluate Applications

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId Enter the internal applicationId. Use the Applications REST API to retrieve the internal applicationId.
 @return ApiPromoteScanRequest
*/
func (a *PolicyEvaluationAPIService) PromoteScan(ctx context.Context, applicationId string) ApiPromoteScanRequest {
	return ApiPromoteScanRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return ApiApplicationEvaluationStatusDTOV2
func (a *PolicyEvaluationAPIService) PromoteScanExecute(r ApiPromoteScanRequest) (*ApiApplicationEvaluationStatusDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiApplicationEvaluationStatusDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyEvaluationAPIService.PromoteScan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/evaluation/applications/{applicationId}/promoteScan"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiPromoteScanRequestDTOV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
