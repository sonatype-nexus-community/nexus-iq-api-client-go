/*
Sonatype Lifecycle Public REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.195.0-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sonatypeiq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SourceControlAPIService SourceControlAPI service
type SourceControlAPIService service

type ApiAddSourceControlRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	ownerType string
	internalOwnerId string
	apiSourceControlDTO *ApiSourceControlDTO
}

// Specify the SCM settings for the ownerId specified above in the request JSON.&lt;ul&gt;&lt;li&gt;&lt;code&gt;id&lt;/code&gt; is the internal owner ID.&lt;/li&gt;&lt;li&gt;&lt;code&gt;repositoryUrl&lt;/code&gt; is the http(s) and ssh urls for the application specified in the ownerId.&lt;/li&gt;&lt;li&gt;&lt;code&gt;username&lt;/code&gt; is optional, can be provided for Bitbucket Server and Cloud.&lt;/li&gt;&lt;li&gt;&lt;code&gt;token&lt;/code&gt; is optional,if inherited. If provided, this value will override the value inherited from the root organization, organization or application level.&lt;li&gt;&lt;code&gt;provider&lt;/code&gt; is the name of of the SCM system. Allowed values are &lt;code&gt;azure&lt;/code&gt;, &lt;code&gt;github&lt;/code&gt;, &lt;code&gt;gitlab&lt;/code&gt;, and &lt;code&gt;bitbucket&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;baseBranch&lt;/code&gt; is required for the root organization. Organizations and applications inherit from the root unless overridden.&lt;/li&gt;&lt;li&gt;&lt;code&gt;enablePullRequests&lt;/code&gt; has been deprecated in version 124.&lt;/li&gt;&lt;li&gt;&lt;code&gt;remediationPullRequestsEnabled&lt;/code&gt; is optional. Set it to &#x60;true&#x60; to enable the Automated Pull Requests.&lt;/li&gt;&lt;li&gt;&lt;code&gt;enableStatusChecks&lt;/code&gt; has been deprecated in version 124.&lt;/li&gt;&lt;li&gt;&lt;code&gt;statusChecksEnabled&lt;/code&gt; is an internal field.&lt;/li&gt;&lt;li&gt;&lt;code&gt;pullRequestCommentingEnabled&lt;/code&gt; is optional. Set it to &#x60;true&#x60; to enable the  Pull Request Commenting feature.&lt;/li&gt;&lt;li&gt;&lt;code&gt;sourceControlEvaluationsEnabled&lt;/code&gt; is set to &#x60;true&#x60; to enable source control evaluations for the continuous risk profile feature.&lt;/li&gt;&lt;li&gt;&lt;code&gt;sourceControlScanTarget&lt;/code&gt; is the path inside the repository.&lt;/li&gt;&lt;li&gt;&lt;code&gt;sshEnabled&lt;/code&gt; is set to &#x60;true&#x60; to enable ssh.&lt;/li&gt;&lt;li&gt;&lt;code&gt;commitStatusEnabled&lt;/code&gt; is set to &#x60;true&#x60; if interaction with the commit statuses on the SCM is enabled.&lt;/li&gt;&lt;/ul&gt;
func (r ApiAddSourceControlRequest) ApiSourceControlDTO(apiSourceControlDTO ApiSourceControlDTO) ApiAddSourceControlRequest {
	r.apiSourceControlDTO = &apiSourceControlDTO
	return r
}

func (r ApiAddSourceControlRequest) Execute() (*ApiSourceControlDTO, *http.Response, error) {
	return r.ApiService.AddSourceControlExecute(r)
}

/*
AddSourceControl Method for AddSourceControl

Use this method to create a source control configuration setting.

Permissions required: Edit IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Enter the value for ownerType.
 @param internalOwnerId Enter the value for internal ownerId. Use ROOT_ORGANIZATION_ID for root organization.
 @return ApiAddSourceControlRequest
*/
func (a *SourceControlAPIService) AddSourceControl(ctx context.Context, ownerType string, internalOwnerId string) ApiAddSourceControlRequest {
	return ApiAddSourceControlRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		internalOwnerId: internalOwnerId,
	}
}

// Execute executes the request
//  @return ApiSourceControlDTO
func (a *SourceControlAPIService) AddSourceControlExecute(r ApiAddSourceControlRequest) (*ApiSourceControlDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiSourceControlDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.AddSourceControl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sourceControl/{ownerType}/{internalOwnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"internalOwnerId"+"}", url.PathEscape(parameterValueToString(r.internalOwnerId, "internalOwnerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiSourceControlDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddUserMappingsRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	organizationId string
	sCMUserMappingsDTO *SCMUserMappingsDTO
}

// &lt;ul&gt;&lt;li&gt;Specify the &#x60;role&#x60; in lowercase, without whitespaces.&lt;/li&gt;&lt;li&gt;&#x60;mappings&#x60; is an array of objects consisting of &#x60;from&#x60; and &#x60;to&#x60; fields.&lt;/li&gt;&lt;li&gt;Allowed values for the &#x60;from&#x60; field are &#x60;SCM_USERNAME&#x60;, &#x60;SCM_EMAIL&#x60;, &#x60;SCM_FULLNAME&#x60;, &#x60;GITLOG_EMAIL&#x60;, &#x60;GITLOG_FULLNAME&#x60;.&lt;/li&gt;&lt;li&gt;Allowed values for &#x60;to&#x60; field are &#x60;IQ_USERNAME&#x60;, &#x60;IQ_EMAIL&#x60;, &#x60;IQ_FULLNAME&#x60;.&lt;/li&gt;&lt;li&gt;Any combination of &#x60;from&#x60; and &#x60;to&#x60; fields can be used.&lt;/li&gt;&lt;/ul&gt;
func (r ApiAddUserMappingsRequest) SCMUserMappingsDTO(sCMUserMappingsDTO SCMUserMappingsDTO) ApiAddUserMappingsRequest {
	r.sCMUserMappingsDTO = &sCMUserMappingsDTO
	return r
}

func (r ApiAddUserMappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddUserMappingsExecute(r)
}

/*
AddUserMappings Method for AddUserMappings

Use this method to apply user mappings from SCM (GitHub) to Lifecycle. The user mappings will be inherited by all child organizations and applications in the organization hierarchy. If a user mapping for an organization already exists, it will be replaced with new mappings provided here.

Permissions required: Edit IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Enter the organizationId. Use `ROOT_ORGANIZATION_ID` for the root organization
 @return ApiAddUserMappingsRequest
*/
func (a *SourceControlAPIService) AddUserMappings(ctx context.Context, organizationId string) ApiAddUserMappingsRequest {
	return ApiAddUserMappingsRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *SourceControlAPIService) AddUserMappingsExecute(r ApiAddUserMappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.AddUserMappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sourceControl/automaticRoleAssignment/userMappings/{organizationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sCMUserMappingsDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAutomaticRoleAssignmentRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	publicId string
	sCMUserMappingsDTO *SCMUserMappingsDTO
}

func (r ApiAutomaticRoleAssignmentRequest) SCMUserMappingsDTO(sCMUserMappingsDTO SCMUserMappingsDTO) ApiAutomaticRoleAssignmentRequest {
	r.sCMUserMappingsDTO = &sCMUserMappingsDTO
	return r
}

func (r ApiAutomaticRoleAssignmentRequest) Execute() (*SCMUserMatchingResultDTO, *http.Response, error) {
	return r.ApiService.AutomaticRoleAssignmentExecute(r)
}

/*
AutomaticRoleAssignment Method for AutomaticRoleAssignment

Use this method to automatically grant the supplied role to all contributors of a repository on a given application.

Prerequisites for automatic role assignment are:<ol><li>SCM configuration for the application and authentication token should exist.</li><li>The contributors to the repository should match a user in IQ based on the supplied mappings.</li><li>Either user mapping strategies have been configured for your organization, or they are provided in the request</li></ol>

Permissions required: Edit access control on the application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param publicId Enter the public applicationId for automatic role assignment.
 @return ApiAutomaticRoleAssignmentRequest
*/
func (a *SourceControlAPIService) AutomaticRoleAssignment(ctx context.Context, publicId string) ApiAutomaticRoleAssignmentRequest {
	return ApiAutomaticRoleAssignmentRequest{
		ApiService: a,
		ctx: ctx,
		publicId: publicId,
	}
}

// Execute executes the request
//  @return SCMUserMatchingResultDTO
func (a *SourceControlAPIService) AutomaticRoleAssignmentExecute(r ApiAutomaticRoleAssignmentRequest) (*SCMUserMatchingResultDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SCMUserMatchingResultDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.AutomaticRoleAssignment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sourceControl/automaticRoleAssignment/{publicId}"
	localVarPath = strings.Replace(localVarPath, "{"+"publicId"+"}", url.PathEscape(parameterValueToString(r.publicId, "publicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sCMUserMappingsDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSourceControlRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	ownerType string
	internalOwnerId string
}

func (r ApiDeleteSourceControlRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSourceControlExecute(r)
}

/*
DeleteSourceControl Method for DeleteSourceControl

Use this method to delete a SCM setting for the specified ownerType/ownerId.

Permissions required: Edit IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Enter the value for ownerType.
 @param internalOwnerId Enter the value for internal ownerId.
 @return ApiDeleteSourceControlRequest
*/
func (a *SourceControlAPIService) DeleteSourceControl(ctx context.Context, ownerType string, internalOwnerId string) ApiDeleteSourceControlRequest {
	return ApiDeleteSourceControlRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		internalOwnerId: internalOwnerId,
	}
}

// Execute executes the request
func (a *SourceControlAPIService) DeleteSourceControlExecute(r ApiDeleteSourceControlRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.DeleteSourceControl")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sourceControl/{ownerType}/{internalOwnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"internalOwnerId"+"}", url.PathEscape(parameterValueToString(r.internalOwnerId, "internalOwnerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteUserMappingsRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	organizationId string
}

func (r ApiDeleteUserMappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserMappingsExecute(r)
}

/*
DeleteUserMappings Method for DeleteUserMappings

Use this method to delete existing SCM user mappings for an organization.

Permissions required: Edit IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Enter the organizationId.
 @return ApiDeleteUserMappingsRequest
*/
func (a *SourceControlAPIService) DeleteUserMappings(ctx context.Context, organizationId string) ApiDeleteUserMappingsRequest {
	return ApiDeleteUserMappingsRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *SourceControlAPIService) DeleteUserMappingsExecute(r ApiDeleteUserMappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.DeleteUserMappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sourceControl/automaticRoleAssignment/userMappings/{organizationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSourceControl1Request struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	ownerType string
	internalOwnerId string
}

func (r ApiGetSourceControl1Request) Execute() (*ApiSourceControlDTO, *http.Response, error) {
	return r.ApiService.GetSourceControl1Execute(r)
}

/*
GetSourceControl1 Method for GetSourceControl1

Use this method to retrieve the source control configuration settings for an organization or an application.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Enter the value for ownerType.
 @param internalOwnerId Enter the value for internal ownerId. Use ROOT_ORGANIZATION_ID for the root organization
 @return ApiGetSourceControl1Request
*/
func (a *SourceControlAPIService) GetSourceControl1(ctx context.Context, ownerType string, internalOwnerId string) ApiGetSourceControl1Request {
	return ApiGetSourceControl1Request{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		internalOwnerId: internalOwnerId,
	}
}

// Execute executes the request
//  @return ApiSourceControlDTO
func (a *SourceControlAPIService) GetSourceControl1Execute(r ApiGetSourceControl1Request) (*ApiSourceControlDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiSourceControlDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.GetSourceControl1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sourceControl/{ownerType}/{internalOwnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"internalOwnerId"+"}", url.PathEscape(parameterValueToString(r.internalOwnerId, "internalOwnerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserMappingsByOwnerRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	ownerType string
	internalOwnerId string
}

func (r ApiGetUserMappingsByOwnerRequest) Execute() (*SCMUserMappingsResponseDTO, *http.Response, error) {
	return r.ApiService.GetUserMappingsByOwnerExecute(r)
}

/*
GetUserMappingsByOwner Method for GetUserMappingsByOwner

Use this method to retrieve SCM user mappings for an organization or application.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Enter the value for ownerType.
 @param internalOwnerId Enter the value for internal ownerId.
 @return ApiGetUserMappingsByOwnerRequest
*/
func (a *SourceControlAPIService) GetUserMappingsByOwner(ctx context.Context, ownerType string, internalOwnerId string) ApiGetUserMappingsByOwnerRequest {
	return ApiGetUserMappingsByOwnerRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		internalOwnerId: internalOwnerId,
	}
}

// Execute executes the request
//  @return SCMUserMappingsResponseDTO
func (a *SourceControlAPIService) GetUserMappingsByOwnerExecute(r ApiGetUserMappingsByOwnerRequest) (*SCMUserMappingsResponseDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SCMUserMappingsResponseDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.GetUserMappingsByOwner")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sourceControl/automaticRoleAssignment/userMappings/{ownerType}/{internalOwnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"internalOwnerId"+"}", url.PathEscape(parameterValueToString(r.internalOwnerId, "internalOwnerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSourceControlRequest struct {
	ctx context.Context
	ApiService *SourceControlAPIService
	ownerType string
	internalOwnerId string
	apiSourceControlDTO *ApiSourceControlDTO
}

// Specify the SCM settings for the ownerId specified above in the request JSON.&lt;ul&gt;&lt;li&gt;&lt;code&gt;id&lt;/code&gt; is the internal owner ID.&lt;/li&gt;&lt;li&gt;&lt;code&gt;repositoryUrl&lt;/code&gt; is the http(s) and ssh urls for the application specified in the ownerId.&lt;/li&gt;&lt;li&gt;&lt;code&gt;username&lt;/code&gt; is optional, can be provided for Bitbucket Server and Cloud.&lt;/li&gt;&lt;li&gt;&lt;code&gt;token&lt;/code&gt; is optional if inherited. If provided, this value will override the value inherited from the root organization, organization or application level.&lt;li&gt;&lt;code&gt;provider&lt;/code&gt; is the name of of the SCM system. Allowed values are &lt;code&gt;azure&lt;/code&gt;, &lt;code&gt;github&lt;/code&gt;, &lt;code&gt;gitlab&lt;/code&gt;, and &lt;code&gt;bitbucket&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;baseBranch&lt;/code&gt; is required for the root organization. Organizations and applications inherit from the root unless overridden.&lt;/li&gt;&lt;li&gt;&lt;code&gt;enablePullRequests&lt;/code&gt; has been deprecated in version 124.&lt;/li&gt;&lt;li&gt;&lt;code&gt;remediationPullRequestsEnabled&lt;/code&gt; is optional. Set it to &#x60;true&#x60; to enable the Automated Pull Requests.&lt;/li&gt;&lt;li&gt;&lt;code&gt;enableStatusChecks&lt;/code&gt; has been deprecated in version 124.&lt;/li&gt;&lt;li&gt;&lt;code&gt;statusChecksEnabled&lt;/code&gt; is an internal field.&lt;/li&gt;&lt;li&gt;&lt;code&gt;pullRequestCommentingEnabled&lt;/code&gt; is optional. Set it to &#x60;true&#x60; to enable the  Pull Request Commenting feature.&lt;/li&gt;&lt;li&gt;&lt;code&gt;sourceControlEvaluationsEnabled&lt;/code&gt; is set to &#x60;true&#x60; to enable source control evaluations for the continuous risk profile feature.&lt;/li&gt;&lt;li&gt;&lt;code&gt;sourceControlScanTarget&lt;/code&gt; is the path inside the repository.&lt;/li&gt;&lt;li&gt;&lt;code&gt;sshEnabled&lt;/code&gt; is set to &#x60;true&#x60; to enable ssh.&lt;/li&gt;&lt;li&gt;&lt;code&gt;commitStatusEnabled&lt;/code&gt; is set to &#x60;true&#x60; if interaction with the commit statuses on the SCM is enabled.&lt;/li&gt;&lt;/ul&gt;
func (r ApiUpdateSourceControlRequest) ApiSourceControlDTO(apiSourceControlDTO ApiSourceControlDTO) ApiUpdateSourceControlRequest {
	r.apiSourceControlDTO = &apiSourceControlDTO
	return r
}

func (r ApiUpdateSourceControlRequest) Execute() (*ApiSourceControlDTO, *http.Response, error) {
	return r.ApiService.UpdateSourceControlExecute(r)
}

/*
UpdateSourceControl Method for UpdateSourceControl

Use this method to update an existing SCM setting.

Permissions required: Edit IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Enter the value for ownerType.
 @param internalOwnerId Enter the internal ownerId. Use ROOT_ORGANIZATION_ID for the root organization.
 @return ApiUpdateSourceControlRequest
*/
func (a *SourceControlAPIService) UpdateSourceControl(ctx context.Context, ownerType string, internalOwnerId string) ApiUpdateSourceControlRequest {
	return ApiUpdateSourceControlRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		internalOwnerId: internalOwnerId,
	}
}

// Execute executes the request
//  @return ApiSourceControlDTO
func (a *SourceControlAPIService) UpdateSourceControlExecute(r ApiUpdateSourceControlRequest) (*ApiSourceControlDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiSourceControlDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SourceControlAPIService.UpdateSourceControl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sourceControl/{ownerType}/{internalOwnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"internalOwnerId"+"}", url.PathEscape(parameterValueToString(r.internalOwnerId, "internalOwnerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiSourceControlDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
