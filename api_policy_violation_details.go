/*
Sonatype Lifecycle Public REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.196.0-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sonatypeiq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// PolicyViolationDetailsAPIService PolicyViolationDetailsAPI service
type PolicyViolationDetailsAPIService service

type ApiGetApplicableAutoWaiverRequest struct {
	ctx context.Context
	ApiService *PolicyViolationDetailsAPIService
	violationId string
}

func (r ApiGetApplicableAutoWaiverRequest) Execute() (*ApiAutoPolicyWaiverDTO, *http.Response, error) {
	return r.ApiService.GetApplicableAutoWaiverExecute(r)
}

/*
GetApplicableAutoWaiver Method for GetApplicableAutoWaiver

Use this method to obtain the existing auto waiver applicable to a policy violationviolation.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param violationId Enter the policy violationId for which you want to obtain the applicable auto policy waiver 
 @return ApiGetApplicableAutoWaiverRequest
*/
func (a *PolicyViolationDetailsAPIService) GetApplicableAutoWaiver(ctx context.Context, violationId string) ApiGetApplicableAutoWaiverRequest {
	return ApiGetApplicableAutoWaiverRequest{
		ApiService: a,
		ctx: ctx,
		violationId: violationId,
	}
}

// Execute executes the request
//  @return ApiAutoPolicyWaiverDTO
func (a *PolicyViolationDetailsAPIService) GetApplicableAutoWaiverExecute(r ApiGetApplicableAutoWaiverRequest) (*ApiAutoPolicyWaiverDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiAutoPolicyWaiverDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationDetailsAPIService.GetApplicableAutoWaiver")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/{violationId}/applicableAutoWaiver"
	localVarPath = strings.Replace(localVarPath, "{"+"violationId"+"}", url.PathEscape(parameterValueToString(r.violationId, "violationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicableWaiverRequestsRequest struct {
	ctx context.Context
	ApiService *PolicyViolationDetailsAPIService
	violationId string
}

func (r ApiGetApplicableWaiverRequestsRequest) Execute() (*ApiPolicyWaiverRequestsApplicableToViolationDTO, *http.Response, error) {
	return r.ApiService.GetApplicableWaiverRequestsExecute(r)
}

/*
GetApplicableWaiverRequests Method for GetApplicableWaiverRequests

Use this method to obtain all existing waiver requests that are applicable to a policy violation. A waiver request is considered as 'applicable' if it matches the following conditions:<ul><li>The policyId for the policy violation matches the policyId associated with the waiver request</li><li>The violated policy conditions match the policy conditions of the waiver request/li><li>The waiver request scope matches the violating component</li></ul>

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param violationId Enter the policy violationId for which you want to obtain the applicable waiver requests.
 @return ApiGetApplicableWaiverRequestsRequest
*/
func (a *PolicyViolationDetailsAPIService) GetApplicableWaiverRequests(ctx context.Context, violationId string) ApiGetApplicableWaiverRequestsRequest {
	return ApiGetApplicableWaiverRequestsRequest{
		ApiService: a,
		ctx: ctx,
		violationId: violationId,
	}
}

// Execute executes the request
//  @return ApiPolicyWaiverRequestsApplicableToViolationDTO
func (a *PolicyViolationDetailsAPIService) GetApplicableWaiverRequestsExecute(r ApiGetApplicableWaiverRequestsRequest) (*ApiPolicyWaiverRequestsApplicableToViolationDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiPolicyWaiverRequestsApplicableToViolationDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationDetailsAPIService.GetApplicableWaiverRequests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/{violationId}/applicableWaiverRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"violationId"+"}", url.PathEscape(parameterValueToString(r.violationId, "violationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicableWaiversRequest struct {
	ctx context.Context
	ApiService *PolicyViolationDetailsAPIService
	violationId string
}

func (r ApiGetApplicableWaiversRequest) Execute() (*ApiPolicyWaiversApplicableToViolationDTO, *http.Response, error) {
	return r.ApiService.GetApplicableWaiversExecute(r)
}

/*
GetApplicableWaivers Method for GetApplicableWaivers

Use this method to obtain all existing waivers that are applicable to a policy violation. A waiver is considered as 'applicable' if it matches the following conditions:<ul><li>The policyId for the policy violation matches the policyId associated with the waiver</li><li>The violated policy conditions match the policy conditions of the waiver/li><li>The waiver scope matches the violating component</li></ul>

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param violationId Enter the policy violationId for which you want to obtain the applicable waivers.
 @return ApiGetApplicableWaiversRequest
*/
func (a *PolicyViolationDetailsAPIService) GetApplicableWaivers(ctx context.Context, violationId string) ApiGetApplicableWaiversRequest {
	return ApiGetApplicableWaiversRequest{
		ApiService: a,
		ctx: ctx,
		violationId: violationId,
	}
}

// Execute executes the request
//  @return ApiPolicyWaiversApplicableToViolationDTO
func (a *PolicyViolationDetailsAPIService) GetApplicableWaiversExecute(r ApiGetApplicableWaiversRequest) (*ApiPolicyWaiversApplicableToViolationDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiPolicyWaiversApplicableToViolationDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationDetailsAPIService.GetApplicableWaivers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/{violationId}/applicableWaivers"
	localVarPath = strings.Replace(localVarPath, "{"+"violationId"+"}", url.PathEscape(parameterValueToString(r.violationId, "violationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCrossStagePolicyViolationByConstituentIdRequest struct {
	ctx context.Context
	ApiService *PolicyViolationDetailsAPIService
	constituentId *string
}

// Enter the violationId. Use the GET method described for the endpoint /api/v2/policyViolations to obtain the policy violationId.
func (r ApiGetCrossStagePolicyViolationByConstituentIdRequest) ConstituentId(constituentId string) ApiGetCrossStagePolicyViolationByConstituentIdRequest {
	r.constituentId = &constituentId
	return r
}

func (r ApiGetCrossStagePolicyViolationByConstituentIdRequest) Execute() (*ApiCrossStageViolationDTOV2, *http.Response, error) {
	return r.ApiService.GetCrossStagePolicyViolationByConstituentIdExecute(r)
}

/*
GetCrossStagePolicyViolationByConstituentId Method for GetCrossStagePolicyViolationByConstituentId

A cross-stage policy violation represents an aggregate of all violations of a policy  occurring across multiple stages of an application. Cross-stage policy violations are helpful in performance analysis by determining the time taken to remediate a violation across all stages where it was detected.
Use this method to retrieve all cross-stage violations, irrespective of the time they were detected.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCrossStagePolicyViolationByConstituentIdRequest
*/
func (a *PolicyViolationDetailsAPIService) GetCrossStagePolicyViolationByConstituentId(ctx context.Context) ApiGetCrossStagePolicyViolationByConstituentIdRequest {
	return ApiGetCrossStagePolicyViolationByConstituentIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiCrossStageViolationDTOV2
func (a *PolicyViolationDetailsAPIService) GetCrossStagePolicyViolationByConstituentIdExecute(r ApiGetCrossStagePolicyViolationByConstituentIdRequest) (*ApiCrossStageViolationDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiCrossStageViolationDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationDetailsAPIService.GetCrossStagePolicyViolationByConstituentId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/crossStage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.constituentId == nil {
		return localVarReturnValue, nil, reportError("constituentId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "constituentId", r.constituentId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCrossStagePolicyViolationByIdRequest struct {
	ctx context.Context
	ApiService *PolicyViolationDetailsAPIService
	violationId string
}

func (r ApiGetCrossStagePolicyViolationByIdRequest) Execute() (*ApiCrossStageViolationDTOV2, *http.Response, error) {
	return r.ApiService.GetCrossStagePolicyViolationByIdExecute(r)
}

/*
GetCrossStagePolicyViolationById Method for GetCrossStagePolicyViolationById

A cross-stage policy violation represents an aggregate of all violations of the same policy, occurring at multiple stages for an application. Cross-stage policy violations are helpful in performance analysis by determining the time taken to remediate a violation across all stages where it was detected.
Use this method to retrieve cross-stage policy violations.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param violationId Enter the policy `violationId`. Use the GET method described for the endpoint /api/v2/policyViolations to obtain the policy violationId. 
 @return ApiGetCrossStagePolicyViolationByIdRequest
*/
func (a *PolicyViolationDetailsAPIService) GetCrossStagePolicyViolationById(ctx context.Context, violationId string) ApiGetCrossStagePolicyViolationByIdRequest {
	return ApiGetCrossStagePolicyViolationByIdRequest{
		ApiService: a,
		ctx: ctx,
		violationId: violationId,
	}
}

// Execute executes the request
//  @return ApiCrossStageViolationDTOV2
func (a *PolicyViolationDetailsAPIService) GetCrossStagePolicyViolationByIdExecute(r ApiGetCrossStagePolicyViolationByIdRequest) (*ApiCrossStageViolationDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiCrossStageViolationDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationDetailsAPIService.GetCrossStagePolicyViolationById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/crossStage/{violationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"violationId"+"}", url.PathEscape(parameterValueToString(r.violationId, "violationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyViolationsRequest struct {
	ctx context.Context
	ApiService *PolicyViolationDetailsAPIService
	p *[]string
	openTimeAfter *string
	openTimeBefore *string
	type_ *[]string
}

// Enter the policyIds to obtain the corresponding violation details
func (r ApiGetPolicyViolationsRequest) P(p []string) ApiGetPolicyViolationsRequest {
	r.p = &p
	return r
}

// Enter the date (format YYYY-MM-DD) from which you want to retrieve the violation details
func (r ApiGetPolicyViolationsRequest) OpenTimeAfter(openTimeAfter string) ApiGetPolicyViolationsRequest {
	r.openTimeAfter = &openTimeAfter
	return r
}

// Enter the date (format YYYY-MM-DD) until which you want to retrieve the violation details
func (r ApiGetPolicyViolationsRequest) OpenTimeBefore(openTimeBefore string) ApiGetPolicyViolationsRequest {
	r.openTimeBefore = &openTimeBefore
	return r
}

// Set one or more policy violation type (active, legacy, waived) to include
func (r ApiGetPolicyViolationsRequest) Type_(type_ []string) ApiGetPolicyViolationsRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetPolicyViolationsRequest) Execute() (*ApiApplicationViolationListDTOV2, *http.Response, error) {
	return r.ApiService.GetPolicyViolationsExecute(r)
}

/*
GetPolicyViolations Method for GetPolicyViolations

Use this method to retrieve policy violation details for a policy/policies. You will need the policyId(s) to retrieve the policy violations details. policyId is available as the response field of the Policies REST API.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPolicyViolationsRequest
*/
func (a *PolicyViolationDetailsAPIService) GetPolicyViolations(ctx context.Context) ApiGetPolicyViolationsRequest {
	return ApiGetPolicyViolationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiApplicationViolationListDTOV2
func (a *PolicyViolationDetailsAPIService) GetPolicyViolationsExecute(r ApiGetPolicyViolationsRequest) (*ApiApplicationViolationListDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiApplicationViolationListDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationDetailsAPIService.GetPolicyViolations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.p == nil {
		return localVarReturnValue, nil, reportError("p is required and must be specified")
	}

	{
		t := *r.p
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "p", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "p", t, "form", "multi")
		}
	}
	if r.openTimeAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "openTimeAfter", r.openTimeAfter, "form", "")
	}
	if r.openTimeBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "openTimeBefore", r.openTimeBefore, "form", "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimilarWaiversRequest struct {
	ctx context.Context
	ApiService *PolicyViolationDetailsAPIService
	violationId string
}

func (r ApiGetSimilarWaiversRequest) Execute() ([]ApiPolicyWaiverDTO, *http.Response, error) {
	return r.ApiService.GetSimilarWaiversExecute(r)
}

/*
GetSimilarWaivers Method for GetSimilarWaivers

Use this method to retrieve similar policy waivers for the given policy violation id.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param violationId Policy violation id to find similar waivers for.
 @return ApiGetSimilarWaiversRequest
*/
func (a *PolicyViolationDetailsAPIService) GetSimilarWaivers(ctx context.Context, violationId string) ApiGetSimilarWaiversRequest {
	return ApiGetSimilarWaiversRequest{
		ApiService: a,
		ctx: ctx,
		violationId: violationId,
	}
}

// Execute executes the request
//  @return []ApiPolicyWaiverDTO
func (a *PolicyViolationDetailsAPIService) GetSimilarWaiversExecute(r ApiGetSimilarWaiversRequest) ([]ApiPolicyWaiverDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApiPolicyWaiverDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationDetailsAPIService.GetSimilarWaivers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/{violationId}/similarWaivers"
	localVarPath = strings.Replace(localVarPath, "{"+"violationId"+"}", url.PathEscape(parameterValueToString(r.violationId, "violationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransitivePolicyViolationsByAppScanComponentRequest struct {
	ctx context.Context
	ApiService *PolicyViolationDetailsAPIService
	ownerType string
	ownerId string
	scanId string
	componentIdentifier *ComponentIdentifier
	packageUrl *string
	hash *string
}

// Enter the component identifier and the coordinates of the component for which you want to retrieve the transitive policy violations. This is optional, not required if package URL or hash value is provided.
func (r ApiGetTransitivePolicyViolationsByAppScanComponentRequest) ComponentIdentifier(componentIdentifier ComponentIdentifier) ApiGetTransitivePolicyViolationsByAppScanComponentRequest {
	r.componentIdentifier = &componentIdentifier
	return r
}

// Enter the package URL for the component for which you want to retrieve the transitive policy violations in the specific scan.
func (r ApiGetTransitivePolicyViolationsByAppScanComponentRequest) PackageUrl(packageUrl string) ApiGetTransitivePolicyViolationsByAppScanComponentRequest {
	r.packageUrl = &packageUrl
	return r
}

// Enter the hash value for the component for which you want to retrieve the transitive policy violations in the specific scan.
func (r ApiGetTransitivePolicyViolationsByAppScanComponentRequest) Hash(hash string) ApiGetTransitivePolicyViolationsByAppScanComponentRequest {
	r.hash = &hash
	return r
}

func (r ApiGetTransitivePolicyViolationsByAppScanComponentRequest) Execute() (*ApiComponentTransitivePolicyViolationsDTO, *http.Response, error) {
	return r.ApiService.GetTransitivePolicyViolationsByAppScanComponentExecute(r)
}

/*
GetTransitivePolicyViolationsByAppScanComponent Method for GetTransitivePolicyViolationsByAppScanComponent

Use this method to retrieve transitive policy violations for a given component in a specific scan.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Enter the scope for this violation. Possible values are 'application'
 @param ownerId Enter the identifier for the scope specified above. E.g. applicationId
 @param scanId Enter the scanId/reportId corresponding to the scan.
 @return ApiGetTransitivePolicyViolationsByAppScanComponentRequest
*/
func (a *PolicyViolationDetailsAPIService) GetTransitivePolicyViolationsByAppScanComponent(ctx context.Context, ownerType string, ownerId string, scanId string) ApiGetTransitivePolicyViolationsByAppScanComponentRequest {
	return ApiGetTransitivePolicyViolationsByAppScanComponentRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
		scanId: scanId,
	}
}

// Execute executes the request
//  @return ApiComponentTransitivePolicyViolationsDTO
func (a *PolicyViolationDetailsAPIService) GetTransitivePolicyViolationsByAppScanComponentExecute(r ApiGetTransitivePolicyViolationsByAppScanComponentRequest) (*ApiComponentTransitivePolicyViolationsDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiComponentTransitivePolicyViolationsDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationDetailsAPIService.GetTransitivePolicyViolationsByAppScanComponent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/transitive/{ownerType}/{ownerId}/{scanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scanId"+"}", url.PathEscape(parameterValueToString(r.scanId, "scanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.componentIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentIdentifier", r.componentIdentifier, "form", "")
	}
	if r.packageUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageUrl", r.packageUrl, "form", "")
	}
	if r.hash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hash", r.hash, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest struct {
	ctx context.Context
	ApiService *PolicyViolationDetailsAPIService
	ownerType string
	ownerId string
	stageId string
	componentIdentifier *ComponentIdentifier
	packageUrl *string
	hash *string
}

// Enter the component identifier and the coordinates of the component for which you want to obtain the transitive violations. This is optional, not required if package URL or hash value is provided.
func (r ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest) ComponentIdentifier(componentIdentifier ComponentIdentifier) ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest {
	r.componentIdentifier = &componentIdentifier
	return r
}

// Enter the package URL of the component. This is optional, not required if component identifier or hash value is provided.
func (r ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest) PackageUrl(packageUrl string) ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest {
	r.packageUrl = &packageUrl
	return r
}

// Enter the hash value of the component. This is optional, not required if component identifier or package URL is provided.
func (r ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest) Hash(hash string) ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest {
	r.hash = &hash
	return r
}

func (r ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest) Execute() (*ApiComponentTransitivePolicyViolationsDTO, *http.Response, error) {
	return r.ApiService.GetTransitivePolicyViolationsByOwnerStageComponentExecute(r)
}

/*
GetTransitivePolicyViolationsByOwnerStageComponent Method for GetTransitivePolicyViolationsByOwnerStageComponent

Use this method to obtain all transitive policy violations for a given component in  a specific stage. Transitive policy violations are violations caused by transitive dependencies.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Possible values are 'application' or 'organization'
 @param ownerId Possible values are applicationId, organizationId
 @param stageId Possible values are 'develop', 'source', 'build', 'stage-release', 'release', and, 'operate'.
 @return ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest
*/
func (a *PolicyViolationDetailsAPIService) GetTransitivePolicyViolationsByOwnerStageComponent(ctx context.Context, ownerType string, ownerId string, stageId string) ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest {
	return ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
		stageId: stageId,
	}
}

// Execute executes the request
//  @return ApiComponentTransitivePolicyViolationsDTO
func (a *PolicyViolationDetailsAPIService) GetTransitivePolicyViolationsByOwnerStageComponentExecute(r ApiGetTransitivePolicyViolationsByOwnerStageComponentRequest) (*ApiComponentTransitivePolicyViolationsDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiComponentTransitivePolicyViolationsDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyViolationDetailsAPIService.GetTransitivePolicyViolationsByOwnerStageComponent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyViolations/transitive/{ownerType}/{ownerId}/stages/{stageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stageId"+"}", url.PathEscape(parameterValueToString(r.stageId, "stageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.componentIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentIdentifier", r.componentIdentifier, "form", "")
	}
	if r.packageUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageUrl", r.packageUrl, "form", "")
	}
	if r.hash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hash", r.hash, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
