/*
Sonatype Lifecycle Public REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.193.0-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sonatypeiq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ApplicationReportDataAPIService ApplicationReportDataAPI service
type ApplicationReportDataAPIService service

type ApiGetDataRequest struct {
	ctx context.Context
	ApiService *ApplicationReportDataAPIService
	applicationPublicId string
	scanId string
}

func (r ApiGetDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetDataExecute(r)
}

/*
GetData Method for GetData

This is an older version of the endpoint. This call will now be redirected to /api/v2/applications/{applicationPublicId}/reports/{scanId}/raw (see below)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationPublicId Enter the applicationPublicId for the evaluated application.
 @param scanId Enter the scanId (reportId) of the application report created after the evaluation. 
 @return ApiGetDataRequest
*/
func (a *ApplicationReportDataAPIService) GetData(ctx context.Context, applicationPublicId string, scanId string) ApiGetDataRequest {
	return ApiGetDataRequest{
		ApiService: a,
		ctx: ctx,
		applicationPublicId: applicationPublicId,
		scanId: scanId,
	}
}

// Execute executes the request
func (a *ApplicationReportDataAPIService) GetDataExecute(r ApiGetDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationReportDataAPIService.GetData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{applicationPublicId}/reports/{scanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationPublicId"+"}", url.PathEscape(parameterValueToString(r.applicationPublicId, "applicationPublicId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scanId"+"}", url.PathEscape(parameterValueToString(r.scanId, "scanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDependencyTreeRequest struct {
	ctx context.Context
	ApiService *ApplicationReportDataAPIService
	applicationPublicId string
	scanId string
}

func (r ApiGetDependencyTreeRequest) Execute() (*ApiDependencyTreeResponseDTO, *http.Response, error) {
	return r.ApiService.GetDependencyTreeExecute(r)
}

/*
GetDependencyTree Method for GetDependencyTree

Use this method to retrieve the dependencies related to the component identified at the time of application evaluation. This is currently available only for Java (Maven) and NPM applications.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationPublicId Enter the applicationPublicId created at the time of creating the application.
 @param scanId  Enter the reportId (scanId) created at the time of evaluating the application.
 @return ApiGetDependencyTreeRequest
*/
func (a *ApplicationReportDataAPIService) GetDependencyTree(ctx context.Context, applicationPublicId string, scanId string) ApiGetDependencyTreeRequest {
	return ApiGetDependencyTreeRequest{
		ApiService: a,
		ctx: ctx,
		applicationPublicId: applicationPublicId,
		scanId: scanId,
	}
}

// Execute executes the request
//  @return ApiDependencyTreeResponseDTO
func (a *ApplicationReportDataAPIService) GetDependencyTreeExecute(r ApiGetDependencyTreeRequest) (*ApiDependencyTreeResponseDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiDependencyTreeResponseDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationReportDataAPIService.GetDependencyTree")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{applicationPublicId}/reports/{scanId}/dependencyTree"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationPublicId"+"}", url.PathEscape(parameterValueToString(r.applicationPublicId, "applicationPublicId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scanId"+"}", url.PathEscape(parameterValueToString(r.scanId, "scanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyViolationDiffRequest struct {
	ctx context.Context
	ApiService *ApplicationReportDataAPIService
	applicationPublicId string
	fromCommit *string
	toCommit *string
	fromPolicyEvaluationId *string
	toPolicyEvaluationId *string
	includeViolationTimes *bool
}

// Enter the commit hash linked to the earlier policy evaluation.
func (r ApiGetPolicyViolationDiffRequest) FromCommit(fromCommit string) ApiGetPolicyViolationDiffRequest {
	r.fromCommit = &fromCommit
	return r
}

// Enter the commit hash linked to the other (later) policy evaluation to compare.
func (r ApiGetPolicyViolationDiffRequest) ToCommit(toCommit string) ApiGetPolicyViolationDiffRequest {
	r.toCommit = &toCommit
	return r
}

// Enter the policy evaluation Id linked to the earlier policy evaluation to compare
func (r ApiGetPolicyViolationDiffRequest) FromPolicyEvaluationId(fromPolicyEvaluationId string) ApiGetPolicyViolationDiffRequest {
	r.fromPolicyEvaluationId = &fromPolicyEvaluationId
	return r
}

// Enter the policy evaluation Id linked to the other (later) policy evaluation to compare
func (r ApiGetPolicyViolationDiffRequest) ToPolicyEvaluationId(toPolicyEvaluationId string) ApiGetPolicyViolationDiffRequest {
	r.toPolicyEvaluationId = &toPolicyEvaluationId
	return r
}

// Set to true to include policy violation times (open, legacy, waived, fixed) in the response if set.
func (r ApiGetPolicyViolationDiffRequest) IncludeViolationTimes(includeViolationTimes bool) ApiGetPolicyViolationDiffRequest {
	r.includeViolationTimes = &includeViolationTimes
	return r
}

func (r ApiGetPolicyViolationDiffRequest) Execute() (*ApiPolicyViolationDiffDTO, *http.Response, error) {
	return r.ApiService.GetPolicyViolationDiffExecute(r)
}

/*
GetPolicyViolationDiff Method for GetPolicyViolationDiff

By configuring Lifecycle with SCM, policy evaluations can be linked to the Git commit hash. Use this method to compare the violations between policy evaluations for 2 commits, by providing the linked commit hashes.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationPublicId Enter the applicationPublicId, created at the time of creating the application
 @return ApiGetPolicyViolationDiffRequest
*/
func (a *ApplicationReportDataAPIService) GetPolicyViolationDiff(ctx context.Context, applicationPublicId string) ApiGetPolicyViolationDiffRequest {
	return ApiGetPolicyViolationDiffRequest{
		ApiService: a,
		ctx: ctx,
		applicationPublicId: applicationPublicId,
	}
}

// Execute executes the request
//  @return ApiPolicyViolationDiffDTO
func (a *ApplicationReportDataAPIService) GetPolicyViolationDiffExecute(r ApiGetPolicyViolationDiffRequest) (*ApiPolicyViolationDiffDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiPolicyViolationDiffDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationReportDataAPIService.GetPolicyViolationDiff")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{applicationPublicId}/reports/policyViolations/diff"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationPublicId"+"}", url.PathEscape(parameterValueToString(r.applicationPublicId, "applicationPublicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromCommit == nil {
		return localVarReturnValue, nil, reportError("fromCommit is required and must be specified")
	}
	if r.toCommit == nil {
		return localVarReturnValue, nil, reportError("toCommit is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fromCommit", r.fromCommit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toCommit", r.toCommit, "form", "")
	if r.fromPolicyEvaluationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromPolicyEvaluationId", r.fromPolicyEvaluationId, "form", "")
	}
	if r.toPolicyEvaluationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toPolicyEvaluationId", r.toPolicyEvaluationId, "form", "")
	}
	if r.includeViolationTimes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeViolationTimes", r.includeViolationTimes, "form", "")
	} else {
		var defaultValue bool = false
		r.includeViolationTimes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyViolations1Request struct {
	ctx context.Context
	ApiService *ApplicationReportDataAPIService
	applicationPublicId string
	scanId string
	includeViolationTimes *bool
}

// Set to true to include policy violation times (open, legacy, waived, fixed) in the response if set.
func (r ApiGetPolicyViolations1Request) IncludeViolationTimes(includeViolationTimes bool) ApiGetPolicyViolations1Request {
	r.includeViolationTimes = &includeViolationTimes
	return r
}

func (r ApiGetPolicyViolations1Request) Execute() (*ApiReportPolicyDataDTOV2, *http.Response, error) {
	return r.ApiService.GetPolicyViolations1Execute(r)
}

/*
GetPolicyViolations1 Method for GetPolicyViolations1

Use this method to retrieve the policy violation data generated as a result of an application evaluation, for each component identified in the application evaluation./n/nPermissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationPublicId Enter the applicationPublicId created at the time of creating the application.
 @param scanId Enter the reportId (scanId) created at the time of evaluating the application.
 @return ApiGetPolicyViolations1Request
*/
func (a *ApplicationReportDataAPIService) GetPolicyViolations1(ctx context.Context, applicationPublicId string, scanId string) ApiGetPolicyViolations1Request {
	return ApiGetPolicyViolations1Request{
		ApiService: a,
		ctx: ctx,
		applicationPublicId: applicationPublicId,
		scanId: scanId,
	}
}

// Execute executes the request
//  @return ApiReportPolicyDataDTOV2
func (a *ApplicationReportDataAPIService) GetPolicyViolations1Execute(r ApiGetPolicyViolations1Request) (*ApiReportPolicyDataDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiReportPolicyDataDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationReportDataAPIService.GetPolicyViolations1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{applicationPublicId}/reports/{scanId}/policy"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationPublicId"+"}", url.PathEscape(parameterValueToString(r.applicationPublicId, "applicationPublicId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scanId"+"}", url.PathEscape(parameterValueToString(r.scanId, "scanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeViolationTimes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeViolationTimes", r.includeViolationTimes, "form", "")
	} else {
		var defaultValue bool = false
		r.includeViolationTimes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawDataRequest struct {
	ctx context.Context
	ApiService *ApplicationReportDataAPIService
	applicationPublicId string
	scanId string
}

func (r ApiGetRawDataRequest) Execute() (*ApiReportRawDataDTOV2, *http.Response, error) {
	return r.ApiService.GetRawDataExecute(r)
}

/*
GetRawData Method for GetRawData

Use this method to retrieve the 'raw' data generated as a result of an application evaluation. 'raw' data includes: the components identified in the application, and the licenses and vulnerabilities associated with the identified components./n/nPermissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationPublicId Enter the applicationPublicId (assigned at the time of creating a new application.) 
 @param scanId Enter the reportId (scanId) created at the time of evaluating the application. application.
 @return ApiGetRawDataRequest
*/
func (a *ApplicationReportDataAPIService) GetRawData(ctx context.Context, applicationPublicId string, scanId string) ApiGetRawDataRequest {
	return ApiGetRawDataRequest{
		ApiService: a,
		ctx: ctx,
		applicationPublicId: applicationPublicId,
		scanId: scanId,
	}
}

// Execute executes the request
//  @return ApiReportRawDataDTOV2
func (a *ApplicationReportDataAPIService) GetRawDataExecute(r ApiGetRawDataRequest) (*ApiReportRawDataDTOV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiReportRawDataDTOV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationReportDataAPIService.GetRawData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/applications/{applicationPublicId}/reports/{scanId}/raw"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationPublicId"+"}", url.PathEscape(parameterValueToString(r.applicationPublicId, "applicationPublicId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scanId"+"}", url.PathEscape(parameterValueToString(r.scanId, "scanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
