/*
Sonatype Lifecycle Public REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.182.0-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sonatypeiq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// SbomAPIService SbomAPI service
type SbomAPIService service

type ApiDeleteSbomVersionRequest struct {
	ctx context.Context
	ApiService *SbomAPIService
	applicationId string
	version string
}

func (r ApiDeleteSbomVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSbomVersionExecute(r)
}

/*
DeleteSbomVersion Delete sbom version

Deletes a specific sbom version including it's original contents and updates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The internal id of the application
 @param version URL Encoded version value of the sbom to be deleted
 @return ApiDeleteSbomVersionRequest
*/
func (a *SbomAPIService) DeleteSbomVersion(ctx context.Context, applicationId string, version string) ApiDeleteSbomVersionRequest {
	return ApiDeleteSbomVersionRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		version: version,
	}
}

// Execute executes the request
func (a *SbomAPIService) DeleteSbomVersionExecute(r ApiDeleteSbomVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SbomAPIService.DeleteSbomVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sbom/applications/{applicationId}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteVulnerabilityAnalysisRequest struct {
	ctx context.Context
	ApiService *SbomAPIService
	applicationId string
	version string
	refId string
	componentLocator *ComponentLocator
}

// Hash or packageUrl to identify the component
func (r ApiDeleteVulnerabilityAnalysisRequest) ComponentLocator(componentLocator ComponentLocator) ApiDeleteVulnerabilityAnalysisRequest {
	r.componentLocator = &componentLocator
	return r
}

func (r ApiDeleteVulnerabilityAnalysisRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVulnerabilityAnalysisExecute(r)
}

/*
DeleteVulnerabilityAnalysis Deletes a Vulnerability analysis for a given component.

Deletes a Vulnerability analysis for a given component.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The internal id of the application
 @param version The version for a specific SBOM where the vulnerability is present
 @param refId The vulnerability id of a vulnerability
 @return ApiDeleteVulnerabilityAnalysisRequest
*/
func (a *SbomAPIService) DeleteVulnerabilityAnalysis(ctx context.Context, applicationId string, version string, refId string) ApiDeleteVulnerabilityAnalysisRequest {
	return ApiDeleteVulnerabilityAnalysisRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		version: version,
		refId: refId,
	}
}

// Execute executes the request
func (a *SbomAPIService) DeleteVulnerabilityAnalysisExecute(r ApiDeleteVulnerabilityAnalysisRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SbomAPIService.DeleteVulnerabilityAnalysis")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sbom/applications/{applicationId}/versions/{version}/vulnerability/{refId}/analysis"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"refId"+"}", url.PathEscape(parameterValueToString(r.refId, "refId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.componentLocator == nil {
		return nil, reportError("componentLocator is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.componentLocator
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetActiveSbomVersionListByApplicationRequest struct {
	ctx context.Context
	ApiService *SbomAPIService
	applicationId string
}

func (r ApiGetActiveSbomVersionListByApplicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetActiveSbomVersionListByApplicationExecute(r)
}

/*
GetActiveSbomVersionListByApplication Gets a list of active sbom versions by application id

Gets a list of active sbom versions by application id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The internal id of the application
 @return ApiGetActiveSbomVersionListByApplicationRequest
*/
func (a *SbomAPIService) GetActiveSbomVersionListByApplication(ctx context.Context, applicationId string) ApiGetActiveSbomVersionListByApplicationRequest {
	return ApiGetActiveSbomVersionListByApplicationRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
func (a *SbomAPIService) GetActiveSbomVersionListByApplicationExecute(r ApiGetActiveSbomVersionListByApplicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SbomAPIService.GetActiveSbomVersionListByApplication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sbom/applications/{applicationId}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetImportStatusRequest struct {
	ctx context.Context
	ApiService *SbomAPIService
	applicationId string
	importRequestId string
}

func (r ApiGetImportStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetImportStatusExecute(r)
}

/*
GetImportStatus Get sbom import status

Gets status of a sbom import.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The internal id of the application
 @param importRequestId The id of the import request
 @return ApiGetImportStatusRequest
*/
func (a *SbomAPIService) GetImportStatus(ctx context.Context, applicationId string, importRequestId string) ApiGetImportStatusRequest {
	return ApiGetImportStatusRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		importRequestId: importRequestId,
	}
}

// Execute executes the request
func (a *SbomAPIService) GetImportStatusExecute(r ApiGetImportStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SbomAPIService.GetImportStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sbom/applications/{applicationId}/status/{importRequestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"importRequestId"+"}", url.PathEscape(parameterValueToString(r.importRequestId, "importRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSbomComponentsRequest struct {
	ctx context.Context
	ApiService *SbomAPIService
	applicationId string
	version string
	vulnerabilityThreatLevels *[]string
	dependencyTypes *[]string
	componentName *string
	sortBy *string
	asc *bool
	page *int32
	pageSize *int32
}

// If provided, filter components by the given threat level on their vulnerabilities
func (r ApiGetSbomComponentsRequest) VulnerabilityThreatLevels(vulnerabilityThreatLevels []string) ApiGetSbomComponentsRequest {
	r.vulnerabilityThreatLevels = &vulnerabilityThreatLevels
	return r
}

// If provided, filter components by the given dependency types
func (r ApiGetSbomComponentsRequest) DependencyTypes(dependencyTypes []string) ApiGetSbomComponentsRequest {
	r.dependencyTypes = &dependencyTypes
	return r
}

// If provided, filter components by the component name
func (r ApiGetSbomComponentsRequest) ComponentName(componentName string) ApiGetSbomComponentsRequest {
	r.componentName = &componentName
	return r
}

// Criteria to sort the results. default &#x3D; VULNERABILITIES
func (r ApiGetSbomComponentsRequest) SortBy(sortBy string) ApiGetSbomComponentsRequest {
	r.sortBy = &sortBy
	return r
}

// Order mode ASC&#x3D;true or DESC&#x3D;false. default &#x3D; false
func (r ApiGetSbomComponentsRequest) Asc(asc bool) ApiGetSbomComponentsRequest {
	r.asc = &asc
	return r
}

// Current page number. default &#x3D; 1
func (r ApiGetSbomComponentsRequest) Page(page int32) ApiGetSbomComponentsRequest {
	r.page = &page
	return r
}

// Number of items to return by page. default &#x3D; 50
func (r ApiGetSbomComponentsRequest) PageSize(pageSize int32) ApiGetSbomComponentsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetSbomComponentsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSbomComponentsExecute(r)
}

/*
GetSbomComponents Gets the components found in a specific sbom version

Lists the components in a specific sbom version with data about vulnerabilities and licenses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The internal id of the application
 @param version URL Encoded version value of the sbom to query its components
 @return ApiGetSbomComponentsRequest
*/
func (a *SbomAPIService) GetSbomComponents(ctx context.Context, applicationId string, version string) ApiGetSbomComponentsRequest {
	return ApiGetSbomComponentsRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		version: version,
	}
}

// Execute executes the request
func (a *SbomAPIService) GetSbomComponentsExecute(r ApiGetSbomComponentsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SbomAPIService.GetSbomComponents")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sbom/applications/{applicationId}/versions/{version}/components"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.vulnerabilityThreatLevels != nil {
		t := *r.vulnerabilityThreatLevels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vulnerabilityThreatLevels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vulnerabilityThreatLevels", t, "form", "multi")
		}
	}
	if r.dependencyTypes != nil {
		t := *r.dependencyTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dependencyTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dependencyTypes", t, "form", "multi")
		}
	}
	if r.componentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentName", r.componentName, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	} else {
		var defaultValue string = "VULNERABILITIES"
		r.sortBy = &defaultValue
	}
	if r.asc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asc", r.asc, "form", "")
	} else {
		var defaultValue bool = false
		r.asc = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 50
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSbomMetadataSummaryForApplicationRequest struct {
	ctx context.Context
	ApiService *SbomAPIService
	applicationId string
	sortByDate *string
	pageSize *int32
	page *int32
}

// Sort results by import date. Allowed values [asc|desc]. default &#x3D; asc
func (r ApiGetSbomMetadataSummaryForApplicationRequest) SortByDate(sortByDate string) ApiGetSbomMetadataSummaryForApplicationRequest {
	r.sortByDate = &sortByDate
	return r
}

// Number of items to return by page. default &#x3D; 10
func (r ApiGetSbomMetadataSummaryForApplicationRequest) PageSize(pageSize int32) ApiGetSbomMetadataSummaryForApplicationRequest {
	r.pageSize = &pageSize
	return r
}

// Current page number. default &#x3D; 1
func (r ApiGetSbomMetadataSummaryForApplicationRequest) Page(page int32) ApiGetSbomMetadataSummaryForApplicationRequest {
	r.page = &page
	return r
}

func (r ApiGetSbomMetadataSummaryForApplicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSbomMetadataSummaryForApplicationExecute(r)
}

/*
GetSbomMetadataSummaryForApplication Gets a paginated list of SBOMs for an application

Gets a paginated list of SBOMs for an application

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The internal id of the application
 @return ApiGetSbomMetadataSummaryForApplicationRequest
*/
func (a *SbomAPIService) GetSbomMetadataSummaryForApplication(ctx context.Context, applicationId string) ApiGetSbomMetadataSummaryForApplicationRequest {
	return ApiGetSbomMetadataSummaryForApplicationRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
func (a *SbomAPIService) GetSbomMetadataSummaryForApplicationExecute(r ApiGetSbomMetadataSummaryForApplicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SbomAPIService.GetSbomMetadataSummaryForApplication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sbom/applications/{applicationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortByDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortByDate", r.sortByDate, "form", "")
	} else {
		var defaultValue string = "asc"
		r.sortByDate = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 10
		r.pageSize = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSbomVersionRequest struct {
	ctx context.Context
	ApiService *SbomAPIService
	applicationId string
	version string
	state *string
	specification *string
	accept *string
}

// The state of the sbom version. Allowed values [original|current]. default &#x3D; current
func (r ApiGetSbomVersionRequest) State(state string) ApiGetSbomVersionRequest {
	r.state = &state
	return r
}

// Target specification of the sbom. Allowed values [cyclonedx1.6|cyclonedx1.5|spdx2.3]. default &#x3D; cyclonedx1.6
func (r ApiGetSbomVersionRequest) Specification(specification string) ApiGetSbomVersionRequest {
	r.specification = &specification
	return r
}

// Output format(json/xml) of the sbom. Changing the output format only applicable when downloading the current form of the SBOM. The original sbom will always return in the original form that it was ingested. When requesting &#x60;current&#x60; form and if this header value is not present the sbom will be returned in its original ingested format. Allowed values {&#39;application/json&#39;|&#39;application/xml&#39;}. default &#x3D; null
func (r ApiGetSbomVersionRequest) Accept(accept string) ApiGetSbomVersionRequest {
	r.accept = &accept
	return r
}

func (r ApiGetSbomVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSbomVersionExecute(r)
}

/*
GetSbomVersion Gets a sbom version

Downloads a specific sbom version in its original or current form

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The internal id of the application
 @param version URL Encoded version value of the sbom
 @return ApiGetSbomVersionRequest
*/
func (a *SbomAPIService) GetSbomVersion(ctx context.Context, applicationId string, version string) ApiGetSbomVersionRequest {
	return ApiGetSbomVersionRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		version: version,
	}
}

// Execute executes the request
func (a *SbomAPIService) GetSbomVersionExecute(r ApiGetSbomVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SbomAPIService.GetSbomVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sbom/applications/{applicationId}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue string = "current"
		r.state = &defaultValue
	}
	if r.specification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "specification", r.specification, "form", "")
	} else {
		var defaultValue string = "cyclonedx1.6"
		r.specification = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json|application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiImportSbomRequest struct {
	ctx context.Context
	ApiService *SbomAPIService
	importSbomRequest *ImportSbomRequest
}

func (r ApiImportSbomRequest) ImportSbomRequest(importSbomRequest ImportSbomRequest) ApiImportSbomRequest {
	r.importSbomRequest = &importSbomRequest
	return r
}

func (r ApiImportSbomRequest) Execute() (*http.Response, error) {
	return r.ApiService.ImportSbomExecute(r)
}

/*
ImportSbom Import a new sbom version

Imports a new sbom version to an existing application

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiImportSbomRequest
*/
func (a *SbomAPIService) ImportSbom(ctx context.Context) ApiImportSbomRequest {
	return ApiImportSbomRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SbomAPIService) ImportSbomExecute(r ApiImportSbomRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SbomAPIService.ImportSbom")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sbom/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.importSbomRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSaveVulnerabilityAnalysisRequest struct {
	ctx context.Context
	ApiService *SbomAPIService
	applicationId string
	version string
	refId string
	sBOMVulnerabilityAnalysisRequest *SBOMVulnerabilityAnalysisRequest
}

// Vulnerability analysis details with component information
func (r ApiSaveVulnerabilityAnalysisRequest) SBOMVulnerabilityAnalysisRequest(sBOMVulnerabilityAnalysisRequest SBOMVulnerabilityAnalysisRequest) ApiSaveVulnerabilityAnalysisRequest {
	r.sBOMVulnerabilityAnalysisRequest = &sBOMVulnerabilityAnalysisRequest
	return r
}

func (r ApiSaveVulnerabilityAnalysisRequest) Execute() (*http.Response, error) {
	return r.ApiService.SaveVulnerabilityAnalysisExecute(r)
}

/*
SaveVulnerabilityAnalysis Updates a vulnerability analysis annotation for a specific SBOM vulnerability

Updates a vulnerability analysis annotation for a specific SBOM vulnerability

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The internal id of the application
 @param version The version for a specific SBOM where the vulnerability is present
 @param refId The vulnerability id of a vulnerability
 @return ApiSaveVulnerabilityAnalysisRequest
*/
func (a *SbomAPIService) SaveVulnerabilityAnalysis(ctx context.Context, applicationId string, version string, refId string) ApiSaveVulnerabilityAnalysisRequest {
	return ApiSaveVulnerabilityAnalysisRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		version: version,
		refId: refId,
	}
}

// Execute executes the request
func (a *SbomAPIService) SaveVulnerabilityAnalysisExecute(r ApiSaveVulnerabilityAnalysisRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SbomAPIService.SaveVulnerabilityAnalysis")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/sbom/applications/{applicationId}/versions/{version}/vulnerability/{refId}/analysis"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"refId"+"}", url.PathEscape(parameterValueToString(r.refId, "refId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sBOMVulnerabilityAnalysisRequest == nil {
		return nil, reportError("sBOMVulnerabilityAnalysisRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sBOMVulnerabilityAnalysisRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
