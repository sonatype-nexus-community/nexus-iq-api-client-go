/*
Sonatype Lifecycle Public REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.184.0-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sonatypeiq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AdvancedSearchAPIService AdvancedSearchAPI service
type AdvancedSearchAPIService service

type ApiCreateSearchIndexAsyncRequest struct {
	ctx context.Context
	ApiService *AdvancedSearchAPIService
}

func (r ApiCreateSearchIndexAsyncRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateSearchIndexAsyncExecute(r)
}

/*
CreateSearchIndexAsync Method for CreateSearchIndexAsync

Use this method to create or rebuild the index for Advanced Search. This is a resource intensive operation. Avoid creating indexes during peak usage hours.

Permissions required: System Administrator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSearchIndexAsyncRequest
*/
func (a *AdvancedSearchAPIService) CreateSearchIndexAsync(ctx context.Context) ApiCreateSearchIndexAsyncRequest {
	return ApiCreateSearchIndexAsyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AdvancedSearchAPIService) CreateSearchIndexAsyncExecute(r ApiCreateSearchIndexAsyncRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdvancedSearchAPIService.CreateSearchIndexAsync")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/search/advanced/index"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetExportResultsRequest struct {
	ctx context.Context
	ApiService *AdvancedSearchAPIService
	query *string
	pageSize *int32
	page *int32
	allComponents *bool
	mode *string
}

// A well-formed search query.
func (r ApiGetExportResultsRequest) Query(query string) ApiGetExportResultsRequest {
	r.query = &query
	return r
}

// Enter the no. of results that should be visible per page, unset gives all results
func (r ApiGetExportResultsRequest) PageSize(pageSize int32) ApiGetExportResultsRequest {
	r.pageSize = &pageSize
	return r
}

// Enter the page no. for the page containing results
func (r ApiGetExportResultsRequest) Page(page int32) ApiGetExportResultsRequest {
	r.page = &page
	return r
}

// Set to &#x60;true&#x60; to retrieve results that include components with no violations.
func (r ApiGetExportResultsRequest) AllComponents(allComponents bool) ApiGetExportResultsRequest {
	r.allComponents = &allComponents
	return r
}

func (r ApiGetExportResultsRequest) Mode(mode string) ApiGetExportResultsRequest {
	r.mode = &mode
	return r
}

func (r ApiGetExportResultsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetExportResultsExecute(r)
}

/*
GetExportResults Method for GetExportResults

Use this method to generate a csv file containing your search results. The default delimiter in the generated file is comma. Use the advancedSearchCSVExportDelimiter property of the Configuration REST API to change the delimiter in the generated file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExportResultsRequest
*/
func (a *AdvancedSearchAPIService) GetExportResults(ctx context.Context) ApiGetExportResultsRequest {
	return ApiGetExportResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AdvancedSearchAPIService) GetExportResultsExecute(r ApiGetExportResultsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdvancedSearchAPIService.GetExportResults")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/search/advanced/export/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return nil, reportError("query is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.allComponents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allComponents", r.allComponents, "form", "")
	} else {
		var defaultValue bool = false
		r.allComponents = &defaultValue
	}
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchIndexRequest struct {
	ctx context.Context
	ApiService *AdvancedSearchAPIService
	query *string
	pageSize *int32
	page *int32
	allComponents *bool
	mode *string
}

// Enter your search query here
func (r ApiSearchIndexRequest) Query(query string) ApiSearchIndexRequest {
	r.query = &query
	return r
}

// Enter the no. of results that should be visible per page
func (r ApiSearchIndexRequest) PageSize(pageSize int32) ApiSearchIndexRequest {
	r.pageSize = &pageSize
	return r
}

// Enter the page no. for the page containing results
func (r ApiSearchIndexRequest) Page(page int32) ApiSearchIndexRequest {
	r.page = &page
	return r
}

// Set to &#x60;true&#x60; to retrieve results that include components with no violations
func (r ApiSearchIndexRequest) AllComponents(allComponents bool) ApiSearchIndexRequest {
	r.allComponents = &allComponents
	return r
}

func (r ApiSearchIndexRequest) Mode(mode string) ApiSearchIndexRequest {
	r.mode = &mode
	return r
}

func (r ApiSearchIndexRequest) Execute() (*SearchResultDTO, *http.Response, error) {
	return r.ApiService.SearchIndexExecute(r)
}

/*
SearchIndex Method for SearchIndex

Use this method to perform an Advanced Search. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchIndexRequest
*/
func (a *AdvancedSearchAPIService) SearchIndex(ctx context.Context) ApiSearchIndexRequest {
	return ApiSearchIndexRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchResultDTO
func (a *AdvancedSearchAPIService) SearchIndexExecute(r ApiSearchIndexRequest) (*SearchResultDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResultDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdvancedSearchAPIService.SearchIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/search/advanced"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 10
		r.pageSize = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.allComponents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allComponents", r.allComponents, "form", "")
	} else {
		var defaultValue bool = false
		r.allComponents = &defaultValue
	}
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
