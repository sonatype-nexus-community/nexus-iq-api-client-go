/*
Sonatype Lifecycle Public REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.195.0-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sonatypeiq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// FirewallAPIService FirewallAPI service
type FirewallAPIService service

type ApiAddProprietaryComponentNamesRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	format string
	requestBody *[]string
}

// List of namespaces to register as proprietary for this format.
func (r ApiAddProprietaryComponentNamesRequest) RequestBody(requestBody []string) ApiAddProprietaryComponentNamesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAddProprietaryComponentNamesRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddProprietaryComponentNamesExecute(r)
}

/*
AddProprietaryComponentNames Method for AddProprietaryComponentNames

Adds a list of proprietary component namespaces for the specified format to prevent namespace confusion attacks.

Permissions required: Evaluate Individual Components

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param format Format for which the proprietary namespaces are being added.
 @return ApiAddProprietaryComponentNamesRequest
*/
func (a *FirewallAPIService) AddProprietaryComponentNames(ctx context.Context, format string) ApiAddProprietaryComponentNamesRequest {
	return ApiAddProprietaryComponentNamesRequest{
		ApiService: a,
		ctx: ctx,
		format: format,
	}
}

// Execute executes the request
func (a *FirewallAPIService) AddProprietaryComponentNamesExecute(r ApiAddProprietaryComponentNamesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.AddProprietaryComponentNames")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/namespace_confusion/{format}"
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", url.PathEscape(parameterValueToString(r.format, "format")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddRepositoryManagerRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	apiRepositoryManagerDTO *ApiRepositoryManagerDTO
}

// Enter values for the new repository manager.
func (r ApiAddRepositoryManagerRequest) ApiRepositoryManagerDTO(apiRepositoryManagerDTO ApiRepositoryManagerDTO) ApiAddRepositoryManagerRequest {
	r.apiRepositoryManagerDTO = &apiRepositoryManagerDTO
	return r
}

func (r ApiAddRepositoryManagerRequest) Execute() (*ApiRepositoryManagerDTO, *http.Response, error) {
	return r.ApiService.AddRepositoryManagerExecute(r)
}

/*
AddRepositoryManager Method for AddRepositoryManager

Use this method to add a new repository manager.

Permissions required: Edit IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddRepositoryManagerRequest
*/
func (a *FirewallAPIService) AddRepositoryManager(ctx context.Context) ApiAddRepositoryManagerRequest {
	return ApiAddRepositoryManagerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiRepositoryManagerDTO
func (a *FirewallAPIService) AddRepositoryManagerExecute(r ApiAddRepositoryManagerRequest) (*ApiRepositoryManagerDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryManagerDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.AddRepositoryManager")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/repositoryManagers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiRepositoryManagerDTO == nil {
		return localVarReturnValue, nil, reportError("apiRepositoryManagerDTO is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRepositoryManagerDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddWaiverRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	containerImageId string
	apiContainerImageWaiverDTO *ApiContainerImageWaiverDTO
}

// The request JSON can include the fields&lt;ol&gt;&lt;li&gt;expiryTime (default null): Sets the datetime when the waiver expires.&lt;/li&gt;&lt;li&gt;waiverReasonId (default null): Sets the specific reason chosen for the waiver.&lt;/li&gt;&lt;li&gt;comment (default null): Further explanation about the waiver.&lt;/li&gt;&lt;/ol&gt;
func (r ApiAddWaiverRequest) ApiContainerImageWaiverDTO(apiContainerImageWaiverDTO ApiContainerImageWaiverDTO) ApiAddWaiverRequest {
	r.apiContainerImageWaiverDTO = &apiContainerImageWaiverDTO
	return r
}

func (r ApiAddWaiverRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddWaiverExecute(r)
}

/*
AddWaiver Method for AddWaiver

Use this method to create a waiver for all policy violations of a container Image. 

Permissions required: Waive Policy Violations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerImageId Enter the container image id.
 @return ApiAddWaiverRequest
*/
func (a *FirewallAPIService) AddWaiver(ctx context.Context, containerImageId string) ApiAddWaiverRequest {
	return ApiAddWaiverRequest{
		ApiService: a,
		ctx: ctx,
		containerImageId: containerImageId,
	}
}

// Execute executes the request
func (a *FirewallAPIService) AddWaiverExecute(r ApiAddWaiverRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.AddWaiver")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/container-image/{containerImageId}/policyWaiver"
	localVarPath = strings.Replace(localVarPath, "{"+"containerImageId"+"}", url.PathEscape(parameterValueToString(r.containerImageId, "containerImageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiContainerImageWaiverDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigureRepositoriesRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	repositoryManagerId string
	apiRepositoryListDTO *ApiRepositoryListDTO
}

// Enter values for the repository configuration properties to be updated.
func (r ApiConfigureRepositoriesRequest) ApiRepositoryListDTO(apiRepositoryListDTO ApiRepositoryListDTO) ApiConfigureRepositoriesRequest {
	r.apiRepositoryListDTO = &apiRepositoryListDTO
	return r
}

func (r ApiConfigureRepositoriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigureRepositoriesExecute(r)
}

/*
ConfigureRepositories Method for ConfigureRepositories

Use this method to update the repositories for an existing repository manager.

Permissions required: Edit IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryManagerId Enter the repository manager ID.
 @return ApiConfigureRepositoriesRequest
*/
func (a *FirewallAPIService) ConfigureRepositories(ctx context.Context, repositoryManagerId string) ApiConfigureRepositoriesRequest {
	return ApiConfigureRepositoriesRequest{
		ApiService: a,
		ctx: ctx,
		repositoryManagerId: repositoryManagerId,
	}
}

// Execute executes the request
func (a *FirewallAPIService) ConfigureRepositoriesExecute(r ApiConfigureRepositoriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.ConfigureRepositories")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/repositories/configuration/{repositoryManagerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryManagerId"+"}", url.PathEscape(parameterValueToString(r.repositoryManagerId, "repositoryManagerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiRepositoryListDTO == nil {
		return nil, reportError("apiRepositoryListDTO is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRepositoryListDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteContainerImagePolicyWaiverRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	containerImageId string
}

func (r ApiDeleteContainerImagePolicyWaiverRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteContainerImagePolicyWaiverExecute(r)
}

/*
DeleteContainerImagePolicyWaiver Method for DeleteContainerImagePolicyWaiver

Use this method to delete a container waiver, specified by the containerImageId.

Permissions required: Waive Policy Violations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerImageId Enter the container id.
 @return ApiDeleteContainerImagePolicyWaiverRequest
*/
func (a *FirewallAPIService) DeleteContainerImagePolicyWaiver(ctx context.Context, containerImageId string) ApiDeleteContainerImagePolicyWaiverRequest {
	return ApiDeleteContainerImagePolicyWaiverRequest{
		ApiService: a,
		ctx: ctx,
		containerImageId: containerImageId,
	}
}

// Execute executes the request
func (a *FirewallAPIService) DeleteContainerImagePolicyWaiverExecute(r ApiDeleteContainerImagePolicyWaiverRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.DeleteContainerImagePolicyWaiver")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/container-image/{containerImageId}/policyWaiver"
	localVarPath = strings.Replace(localVarPath, "{"+"containerImageId"+"}", url.PathEscape(parameterValueToString(r.containerImageId, "containerImageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRepositoryManagerRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	repositoryManagerId string
}

func (r ApiDeleteRepositoryManagerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRepositoryManagerExecute(r)
}

/*
DeleteRepositoryManager Method for DeleteRepositoryManager

Use this method to delete an existing repository manager.

Permissions required: Edit IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryManagerId Enter the repository manager ID.
 @return ApiDeleteRepositoryManagerRequest
*/
func (a *FirewallAPIService) DeleteRepositoryManager(ctx context.Context, repositoryManagerId string) ApiDeleteRepositoryManagerRequest {
	return ApiDeleteRepositoryManagerRequest{
		ApiService: a,
		ctx: ctx,
		repositoryManagerId: repositoryManagerId,
	}
}

// Execute executes the request
func (a *FirewallAPIService) DeleteRepositoryManagerExecute(r ApiDeleteRepositoryManagerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.DeleteRepositoryManager")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/repositoryManagers/{repositoryManagerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryManagerId"+"}", url.PathEscape(parameterValueToString(r.repositoryManagerId, "repositoryManagerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEvaluateComponents1Request struct {
	ctx context.Context
	ApiService *FirewallAPIService
	repositoryManagerId string
	repositoryId string
	apiRepositoryComponentEvaluationRequestList *ApiRepositoryComponentEvaluationRequestList
}

// Provide the array of the component identifiers to be evaluated, using the component hash and the (packageUrl or pathname). A maximum of 100 components can be evaluated in one request.
func (r ApiEvaluateComponents1Request) ApiRepositoryComponentEvaluationRequestList(apiRepositoryComponentEvaluationRequestList ApiRepositoryComponentEvaluationRequestList) ApiEvaluateComponents1Request {
	r.apiRepositoryComponentEvaluationRequestList = &apiRepositoryComponentEvaluationRequestList
	return r
}

func (r ApiEvaluateComponents1Request) Execute() (*ApiRepositoryComponentEvaluationResultList, *http.Response, error) {
	return r.ApiService.EvaluateComponents1Execute(r)
}

/*
EvaluateComponents1 Method for EvaluateComponents1

Use this method to evaluate components (max. 100).

Permissions required: Evaluate Individual Components

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryManagerId Enter the repository manager ID.
 @param repositoryId Enter the repository ID.
 @return ApiEvaluateComponents1Request
*/
func (a *FirewallAPIService) EvaluateComponents1(ctx context.Context, repositoryManagerId string, repositoryId string) ApiEvaluateComponents1Request {
	return ApiEvaluateComponents1Request{
		ApiService: a,
		ctx: ctx,
		repositoryManagerId: repositoryManagerId,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
//  @return ApiRepositoryComponentEvaluationResultList
func (a *FirewallAPIService) EvaluateComponents1Execute(r ApiEvaluateComponents1Request) (*ApiRepositoryComponentEvaluationResultList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryComponentEvaluationResultList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.EvaluateComponents1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/components/{repositoryManagerId}/{repositoryId}/evaluate"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryManagerId"+"}", url.PathEscape(parameterValueToString(r.repositoryManagerId, "repositoryManagerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryId"+"}", url.PathEscape(parameterValueToString(r.repositoryId, "repositoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiRepositoryComponentEvaluationRequestList == nil {
		return localVarReturnValue, nil, reportError("apiRepositoryComponentEvaluationRequestList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRepositoryComponentEvaluationRequestList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEvaluateMalwareRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	apiMalwareComponentEvaluationRequestList *ApiMalwareComponentEvaluationRequestList
}

func (r ApiEvaluateMalwareRequest) ApiMalwareComponentEvaluationRequestList(apiMalwareComponentEvaluationRequestList ApiMalwareComponentEvaluationRequestList) ApiEvaluateMalwareRequest {
	r.apiMalwareComponentEvaluationRequestList = &apiMalwareComponentEvaluationRequestList
	return r
}

func (r ApiEvaluateMalwareRequest) Execute() (*MalwareDefenseResponseList, *http.Response, error) {
	return r.ApiService.EvaluateMalwareExecute(r)
}

/*
EvaluateMalware Method for EvaluateMalware

Evaluate malware for a list of components.<p>Use this endpoint to evaluate malware for a list of components up to a maximum of 100 components in a single request.A hash or packageUrl (or both) can be supplied for each component that are of the same format type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEvaluateMalwareRequest
*/
func (a *FirewallAPIService) EvaluateMalware(ctx context.Context) ApiEvaluateMalwareRequest {
	return ApiEvaluateMalwareRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MalwareDefenseResponseList
func (a *FirewallAPIService) EvaluateMalwareExecute(r ApiEvaluateMalwareRequest) (*MalwareDefenseResponseList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MalwareDefenseResponseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.EvaluateMalware")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/evaluate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiMalwareComponentEvaluationRequestList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfiguredRepositoriesRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	repositoryManagerId string
	sinceUtcTimestamp *int64
}

// Enter the epoch time in milliseconds when the repository was last updated.
func (r ApiGetConfiguredRepositoriesRequest) SinceUtcTimestamp(sinceUtcTimestamp int64) ApiGetConfiguredRepositoriesRequest {
	r.sinceUtcTimestamp = &sinceUtcTimestamp
	return r
}

func (r ApiGetConfiguredRepositoriesRequest) Execute() (*ApiRepositoryListDTO, *http.Response, error) {
	return r.ApiService.GetConfiguredRepositoriesExecute(r)
}

/*
GetConfiguredRepositories Method for GetConfiguredRepositories

Use this method to retrieve the configuration details of an existing repository manager.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryManagerId Enter the repository manager ID.
 @return ApiGetConfiguredRepositoriesRequest
*/
func (a *FirewallAPIService) GetConfiguredRepositories(ctx context.Context, repositoryManagerId string) ApiGetConfiguredRepositoriesRequest {
	return ApiGetConfiguredRepositoriesRequest{
		ApiService: a,
		ctx: ctx,
		repositoryManagerId: repositoryManagerId,
	}
}

// Execute executes the request
//  @return ApiRepositoryListDTO
func (a *FirewallAPIService) GetConfiguredRepositoriesExecute(r ApiGetConfiguredRepositoriesRequest) (*ApiRepositoryListDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryListDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetConfiguredRepositories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/repositories/configuration/{repositoryManagerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryManagerId"+"}", url.PathEscape(parameterValueToString(r.repositoryManagerId, "repositoryManagerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sinceUtcTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sinceUtcTimestamp", r.sinceUtcTimestamp, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerImagesInQuarantineRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	page *int32
	pageSize *int32
}

func (r ApiGetContainerImagesInQuarantineRequest) Page(page int32) ApiGetContainerImagesInQuarantineRequest {
	r.page = &page
	return r
}

func (r ApiGetContainerImagesInQuarantineRequest) PageSize(pageSize int32) ApiGetContainerImagesInQuarantineRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetContainerImagesInQuarantineRequest) Execute() (*ContainerImageInQuarantineDataResult, *http.Response, error) {
	return r.ApiService.GetContainerImagesInQuarantineExecute(r)
}

/*
GetContainerImagesInQuarantine Method for GetContainerImagesInQuarantine

Use this method to find all container images currently in quarantine.

Permissions required: Read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetContainerImagesInQuarantineRequest
*/
func (a *FirewallAPIService) GetContainerImagesInQuarantine(ctx context.Context) ApiGetContainerImagesInQuarantineRequest {
	return ApiGetContainerImagesInQuarantineRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContainerImageInQuarantineDataResult
func (a *FirewallAPIService) GetContainerImagesInQuarantineExecute(r ApiGetContainerImagesInQuarantineRequest) (*ContainerImageInQuarantineDataResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContainerImageInQuarantineDataResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetContainerImagesInQuarantine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/container-image/policyViolations/quarantined"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallAutoUnquarantineConfigRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetFirewallAutoUnquarantineConfigRequest) Execute() ([]ApiFirewallReleaseQuarantineConfigDTO, *http.Response, error) {
	return r.ApiService.GetFirewallAutoUnquarantineConfigExecute(r)
}

/*
GetFirewallAutoUnquarantineConfig Method for GetFirewallAutoUnquarantineConfig

Use this method to retrieve the configuration settings for auto-release from quarantine for repositories.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFirewallAutoUnquarantineConfigRequest
*/
func (a *FirewallAPIService) GetFirewallAutoUnquarantineConfig(ctx context.Context) ApiGetFirewallAutoUnquarantineConfigRequest {
	return ApiGetFirewallAutoUnquarantineConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApiFirewallReleaseQuarantineConfigDTO
func (a *FirewallAPIService) GetFirewallAutoUnquarantineConfigExecute(r ApiGetFirewallAutoUnquarantineConfigRequest) ([]ApiFirewallReleaseQuarantineConfigDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApiFirewallReleaseQuarantineConfigDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetFirewallAutoUnquarantineConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/releaseQuarantine/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallMetricsRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetFirewallMetricsRequest) Execute() (*map[string]ApiFirewallMetricsResultDTO, *http.Response, error) {
	return r.ApiService.GetFirewallMetricsExecute(r)
}

/*
GetFirewallMetrics Method for GetFirewallMetrics

Use this method to retrieve malware defense dashboard metrics.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFirewallMetricsRequest
*/
func (a *FirewallAPIService) GetFirewallMetrics(ctx context.Context) ApiGetFirewallMetricsRequest {
	return ApiGetFirewallMetricsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]ApiFirewallMetricsResultDTO
func (a *FirewallAPIService) GetFirewallMetricsExecute(r ApiGetFirewallMetricsRequest) (*map[string]ApiFirewallMetricsResultDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]ApiFirewallMetricsResultDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetFirewallMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/metrics/embedded"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallUnquarantineSummaryRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetFirewallUnquarantineSummaryRequest) Execute() (*ApiFirewallReleaseQuarantineSummaryDTO, *http.Response, error) {
	return r.ApiService.GetFirewallUnquarantineSummaryExecute(r)
}

/*
GetFirewallUnquarantineSummary Method for GetFirewallUnquarantineSummary

Use this method to track how many components have been automatically released from quarantine over different time periods.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFirewallUnquarantineSummaryRequest
*/
func (a *FirewallAPIService) GetFirewallUnquarantineSummary(ctx context.Context) ApiGetFirewallUnquarantineSummaryRequest {
	return ApiGetFirewallUnquarantineSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiFirewallReleaseQuarantineSummaryDTO
func (a *FirewallAPIService) GetFirewallUnquarantineSummaryExecute(r ApiGetFirewallUnquarantineSummaryRequest) (*ApiFirewallReleaseQuarantineSummaryDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiFirewallReleaseQuarantineSummaryDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetFirewallUnquarantineSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/releaseQuarantine/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMalwareDefenseMetricsRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetMalwareDefenseMetricsRequest) Execute() (map[string]int64, *http.Response, error) {
	return r.ApiService.GetMalwareDefenseMetricsExecute(r)
}

/*
GetMalwareDefenseMetrics Method for GetMalwareDefenseMetrics

The response contains malware defense API metrics.<p>Use this endpoint to get the count of malicious components evaluated via malware defense API grouped by format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMalwareDefenseMetricsRequest
*/
func (a *FirewallAPIService) GetMalwareDefenseMetrics(ctx context.Context) ApiGetMalwareDefenseMetricsRequest {
	return ApiGetMalwareDefenseMetricsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]int64
func (a *FirewallAPIService) GetMalwareDefenseMetricsExecute(r ApiGetMalwareDefenseMetricsRequest) (map[string]int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetMalwareDefenseMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/metrics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuarantineListRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	page *int32
	pageSize *int32
	policyId *[]string
	componentName *string
	repositoryPublicId *string
	quarantineTime *int32
	sortBy *string
	asc *bool
}

// Enter the starting page number for the response.
func (r ApiGetQuarantineListRequest) Page(page int32) ApiGetQuarantineListRequest {
	r.page = &page
	return r
}

// Enter the page size for the response.
func (r ApiGetQuarantineListRequest) PageSize(pageSize int32) ApiGetQuarantineListRequest {
	r.pageSize = &pageSize
	return r
}

// Enter the list of policy IDs causing the quarantine.
func (r ApiGetQuarantineListRequest) PolicyId(policyId []string) ApiGetQuarantineListRequest {
	r.policyId = &policyId
	return r
}

// Enter the component name.
func (r ApiGetQuarantineListRequest) ComponentName(componentName string) ApiGetQuarantineListRequest {
	r.componentName = &componentName
	return r
}

// Enter the repository public ID of the quarantined component.
func (r ApiGetQuarantineListRequest) RepositoryPublicId(repositoryPublicId string) ApiGetQuarantineListRequest {
	r.repositoryPublicId = &repositoryPublicId
	return r
}

// Enter the quarantine time of the component.
func (r ApiGetQuarantineListRequest) QuarantineTime(quarantineTime int32) ApiGetQuarantineListRequest {
	r.quarantineTime = &quarantineTime
	return r
}

// Enter &#x60;quarantineTime&#x60; to sort the results by quarantine time.
func (r ApiGetQuarantineListRequest) SortBy(sortBy string) ApiGetQuarantineListRequest {
	r.sortBy = &sortBy
	return r
}

// Select the sort order.
func (r ApiGetQuarantineListRequest) Asc(asc bool) ApiGetQuarantineListRequest {
	r.asc = &asc
	return r
}

func (r ApiGetQuarantineListRequest) Execute() (*ApiFirewallQuarantinedComponentDtoResult, *http.Response, error) {
	return r.ApiService.GetQuarantineListExecute(r)
}

/*
GetQuarantineList Method for GetQuarantineList

Use this method to request a list of quarantined components.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQuarantineListRequest
*/
func (a *FirewallAPIService) GetQuarantineList(ctx context.Context) ApiGetQuarantineListRequest {
	return ApiGetQuarantineListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiFirewallQuarantinedComponentDtoResult
func (a *FirewallAPIService) GetQuarantineListExecute(r ApiGetQuarantineListRequest) (*ApiFirewallQuarantinedComponentDtoResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiFirewallQuarantinedComponentDtoResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetQuarantineList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/components/quarantined"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 10
		r.pageSize = &defaultValue
	}
	if r.policyId != nil {
		t := *r.policyId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policyId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policyId", t, "form", "multi")
		}
	}
	if r.componentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentName", r.componentName, "form", "")
	}
	if r.repositoryPublicId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "repositoryPublicId", r.repositoryPublicId, "form", "")
	}
	if r.quarantineTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quarantineTime", r.quarantineTime, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	}
	if r.asc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asc", r.asc, "form", "")
	} else {
		var defaultValue bool = false
		r.asc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuarantineSummaryRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetQuarantineSummaryRequest) Execute() (*ApiFirewallQuarantineSummaryDTO, *http.Response, error) {
	return r.ApiService.GetQuarantineSummaryExecute(r)
}

/*
GetQuarantineSummary Method for GetQuarantineSummary

Use this method to request a summary of quarantined components.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQuarantineSummaryRequest
*/
func (a *FirewallAPIService) GetQuarantineSummary(ctx context.Context) ApiGetQuarantineSummaryRequest {
	return ApiGetQuarantineSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiFirewallQuarantineSummaryDTO
func (a *FirewallAPIService) GetQuarantineSummaryExecute(r ApiGetQuarantineSummaryRequest) (*ApiFirewallQuarantineSummaryDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiFirewallQuarantineSummaryDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetQuarantineSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/quarantine/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuarantinedComponentViewAnonymousAccessRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetQuarantinedComponentViewAnonymousAccessRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.GetQuarantinedComponentViewAnonymousAccessExecute(r)
}

/*
GetQuarantinedComponentViewAnonymousAccess Method for GetQuarantinedComponentViewAnonymousAccess

Use this method to determine if the quarantined component(s) details can be accessed anonymously.

Permissions required: None

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQuarantinedComponentViewAnonymousAccessRequest
*/
func (a *FirewallAPIService) GetQuarantinedComponentViewAnonymousAccess(ctx context.Context) ApiGetQuarantinedComponentViewAnonymousAccessRequest {
	return ApiGetQuarantinedComponentViewAnonymousAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *FirewallAPIService) GetQuarantinedComponentViewAnonymousAccessExecute(r ApiGetQuarantinedComponentViewAnonymousAccessRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetQuarantinedComponentViewAnonymousAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/quarantinedComponentView/configuration/anonymousAccess"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepositoryContainerRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetRepositoryContainerRequest) Execute() (*ApiRepositoryContainerDTO, *http.Response, error) {
	return r.ApiService.GetRepositoryContainerExecute(r)
}

/*
GetRepositoryContainer Method for GetRepositoryContainer

Use this method to retrieve the ID and name for the repository container.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRepositoryContainerRequest
*/
func (a *FirewallAPIService) GetRepositoryContainer(ctx context.Context) ApiGetRepositoryContainerRequest {
	return ApiGetRepositoryContainerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiRepositoryContainerDTO
func (a *FirewallAPIService) GetRepositoryContainerExecute(r ApiGetRepositoryContainerRequest) (*ApiRepositoryContainerDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryContainerDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetRepositoryContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/repositoryContainer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepositoryManagerRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	repositoryManagerId string
}

func (r ApiGetRepositoryManagerRequest) Execute() (*ApiRepositoryManagerDTO, *http.Response, error) {
	return r.ApiService.GetRepositoryManagerExecute(r)
}

/*
GetRepositoryManager Method for GetRepositoryManager

Use this method to retrieve details of an existing repository manager.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryManagerId Enter the repository manager ID.
 @return ApiGetRepositoryManagerRequest
*/
func (a *FirewallAPIService) GetRepositoryManager(ctx context.Context, repositoryManagerId string) ApiGetRepositoryManagerRequest {
	return ApiGetRepositoryManagerRequest{
		ApiService: a,
		ctx: ctx,
		repositoryManagerId: repositoryManagerId,
	}
}

// Execute executes the request
//  @return ApiRepositoryManagerDTO
func (a *FirewallAPIService) GetRepositoryManagerExecute(r ApiGetRepositoryManagerRequest) (*ApiRepositoryManagerDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryManagerDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetRepositoryManager")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/repositoryManagers/{repositoryManagerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryManagerId"+"}", url.PathEscape(parameterValueToString(r.repositoryManagerId, "repositoryManagerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepositoryManagersRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetRepositoryManagersRequest) Execute() (*ApiRepositoryManagerListDTO, *http.Response, error) {
	return r.ApiService.GetRepositoryManagersExecute(r)
}

/*
GetRepositoryManagers Method for GetRepositoryManagers

Use this method to retrieve all configured repository managers.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRepositoryManagersRequest
*/
func (a *FirewallAPIService) GetRepositoryManagers(ctx context.Context) ApiGetRepositoryManagersRequest {
	return ApiGetRepositoryManagersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiRepositoryManagerListDTO
func (a *FirewallAPIService) GetRepositoryManagersExecute(r ApiGetRepositoryManagersRequest) (*ApiRepositoryManagerListDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryManagerListDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetRepositoryManagers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/repositoryManagers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoiFirewallMetricsRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	currencyType string
}

func (r ApiGetRoiFirewallMetricsRequest) Execute() (*RoiFirewallMetricsDTO, *http.Response, error) {
	return r.ApiService.GetRoiFirewallMetricsExecute(r)
}

/*
GetRoiFirewallMetrics Method for GetRoiFirewallMetrics

Use this method to retrieve ROI malware defense metrics for the specified currency type.

Permissions required: Edit System Configuration and Users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyType The currency to use for the ROI malware defense metrics.
 @return ApiGetRoiFirewallMetricsRequest
*/
func (a *FirewallAPIService) GetRoiFirewallMetrics(ctx context.Context, currencyType string) ApiGetRoiFirewallMetricsRequest {
	return ApiGetRoiFirewallMetricsRequest{
		ApiService: a,
		ctx: ctx,
		currencyType: currencyType,
	}
}

// Execute executes the request
//  @return RoiFirewallMetricsDTO
func (a *FirewallAPIService) GetRoiFirewallMetricsExecute(r ApiGetRoiFirewallMetricsRequest) (*RoiFirewallMetricsDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoiFirewallMetricsDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetRoiFirewallMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/metrics/embedded/roi-firewall-metrics/{currencyType}"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyType"+"}", url.PathEscape(parameterValueToString(r.currencyType, "currencyType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUnquarantineListRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	page *int32
	pageSize *int32
	policyId *string
	componentName *string
	sortBy *string
	asc *bool
}

// Enter the page number.
func (r ApiGetUnquarantineListRequest) Page(page int32) ApiGetUnquarantineListRequest {
	r.page = &page
	return r
}

// Enter the number of results to be returned for a page.
func (r ApiGetUnquarantineListRequest) PageSize(pageSize int32) ApiGetUnquarantineListRequest {
	r.pageSize = &pageSize
	return r
}

// Enter the &#x60;policyId&#x60;. When provided, the results will include the components that have a policy violation for the policyId.
func (r ApiGetUnquarantineListRequest) PolicyId(policyId string) ApiGetUnquarantineListRequest {
	r.policyId = &policyId
	return r
}

// Enter the component name. When provided, the results will include components with display names (case-insensitive) that match the given name.
func (r ApiGetUnquarantineListRequest) ComponentName(componentName string) ApiGetUnquarantineListRequest {
	r.componentName = &componentName
	return r
}

// Enter the sort criteria &#x60;releaseQuarantineTime&#x60; or &#x60;quarantineTime&#x60;.
func (r ApiGetUnquarantineListRequest) SortBy(sortBy string) ApiGetUnquarantineListRequest {
	r.sortBy = &sortBy
	return r
}

// Select &#x60;true&#x60; to set the sort order to ascending.
func (r ApiGetUnquarantineListRequest) Asc(asc bool) ApiGetUnquarantineListRequest {
	r.asc = &asc
	return r
}

func (r ApiGetUnquarantineListRequest) Execute() (*ApiFirewallComponentDTOResult, *http.Response, error) {
	return r.ApiService.GetUnquarantineListExecute(r)
}

/*
GetUnquarantineList Method for GetUnquarantineList

Use this method to retrieve the details of components that are auto-released from quarantine.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUnquarantineListRequest
*/
func (a *FirewallAPIService) GetUnquarantineList(ctx context.Context) ApiGetUnquarantineListRequest {
	return ApiGetUnquarantineListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiFirewallComponentDTOResult
func (a *FirewallAPIService) GetUnquarantineListExecute(r ApiGetUnquarantineListRequest) (*ApiFirewallComponentDTOResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiFirewallComponentDTOResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetUnquarantineList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/components/autoReleasedFromQuarantine"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 10
		r.pageSize = &defaultValue
	}
	if r.policyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyId", r.policyId, "form", "")
	}
	if r.componentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentName", r.componentName, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	}
	if r.asc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asc", r.asc, "form", "")
	} else {
		var defaultValue bool = true
		r.asc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWaiversRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	page *int32
	pageSize *int32
}

func (r ApiGetWaiversRequest) Page(page int32) ApiGetWaiversRequest {
	r.page = &page
	return r
}

func (r ApiGetWaiversRequest) PageSize(pageSize int32) ApiGetWaiversRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetWaiversRequest) Execute() (*PolicyContainerWaiverDataResult, *http.Response, error) {
	return r.ApiService.GetWaiversExecute(r)
}

/*
GetWaivers Method for GetWaivers

Use this method to get all policy waivers for container images. 

Permissions required: Waive Policy Violations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWaiversRequest
*/
func (a *FirewallAPIService) GetWaivers(ctx context.Context) ApiGetWaiversRequest {
	return ApiGetWaiversRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PolicyContainerWaiverDataResult
func (a *FirewallAPIService) GetWaiversExecute(r ApiGetWaiversRequest) (*PolicyContainerWaiverDataResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyContainerWaiverDataResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetWaivers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/container-image/policyWaiver"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveProprietaryComponentNamesRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	format string
}

func (r ApiRemoveProprietaryComponentNamesRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveProprietaryComponentNamesExecute(r)
}

/*
RemoveProprietaryComponentNames Method for RemoveProprietaryComponentNames

Removes proprietary component namespaces for the specified format.

Permissions required: Evaluate Individual Components

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param format Format for which the proprietary namespaces are being removed.
 @return ApiRemoveProprietaryComponentNamesRequest
*/
func (a *FirewallAPIService) RemoveProprietaryComponentNames(ctx context.Context, format string) ApiRemoveProprietaryComponentNamesRequest {
	return ApiRemoveProprietaryComponentNamesRequest{
		ApiService: a,
		ctx: ctx,
		format: format,
	}
}

// Execute executes the request
func (a *FirewallAPIService) RemoveProprietaryComponentNamesExecute(r ApiRemoveProprietaryComponentNamesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.RemoveProprietaryComponentNames")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/namespace_confusion/{format}"
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", url.PathEscape(parameterValueToString(r.format, "format")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetFirewallAutoUnquarantineConfigRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	apiFirewallReleaseQuarantineConfigDTO *[]ApiFirewallReleaseQuarantineConfigDTO
}

// Enter value for each repository and the required status for auto-release as &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiSetFirewallAutoUnquarantineConfigRequest) ApiFirewallReleaseQuarantineConfigDTO(apiFirewallReleaseQuarantineConfigDTO []ApiFirewallReleaseQuarantineConfigDTO) ApiSetFirewallAutoUnquarantineConfigRequest {
	r.apiFirewallReleaseQuarantineConfigDTO = &apiFirewallReleaseQuarantineConfigDTO
	return r
}

func (r ApiSetFirewallAutoUnquarantineConfigRequest) Execute() ([]ApiFirewallReleaseQuarantineConfigDTO, *http.Response, error) {
	return r.ApiService.SetFirewallAutoUnquarantineConfigExecute(r)
}

/*
SetFirewallAutoUnquarantineConfig Method for SetFirewallAutoUnquarantineConfig

Use this method to set the configurations for auto-release from quarantine for a list of repositories.

Permissions required: Edit IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetFirewallAutoUnquarantineConfigRequest
*/
func (a *FirewallAPIService) SetFirewallAutoUnquarantineConfig(ctx context.Context) ApiSetFirewallAutoUnquarantineConfigRequest {
	return ApiSetFirewallAutoUnquarantineConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApiFirewallReleaseQuarantineConfigDTO
func (a *FirewallAPIService) SetFirewallAutoUnquarantineConfigExecute(r ApiSetFirewallAutoUnquarantineConfigRequest) ([]ApiFirewallReleaseQuarantineConfigDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApiFirewallReleaseQuarantineConfigDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.SetFirewallAutoUnquarantineConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/releaseQuarantine/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiFirewallReleaseQuarantineConfigDTO == nil {
		return localVarReturnValue, nil, reportError("apiFirewallReleaseQuarantineConfigDTO is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiFirewallReleaseQuarantineConfigDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetQuarantinedComponentViewAnonymousAccessRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	enabled bool
}

func (r ApiSetQuarantinedComponentViewAnonymousAccessRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetQuarantinedComponentViewAnonymousAccessExecute(r)
}

/*
SetQuarantinedComponentViewAnonymousAccess Method for SetQuarantinedComponentViewAnonymousAccess

Use this method to enable/disable anonymous access to view the quarantined components.

Permissions required: Edit IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enabled Select `true` or `false` to enable or disable anonymous access.
 @return ApiSetQuarantinedComponentViewAnonymousAccessRequest
*/
func (a *FirewallAPIService) SetQuarantinedComponentViewAnonymousAccess(ctx context.Context, enabled bool) ApiSetQuarantinedComponentViewAnonymousAccessRequest {
	return ApiSetQuarantinedComponentViewAnonymousAccessRequest{
		ApiService: a,
		ctx: ctx,
		enabled: enabled,
	}
}

// Execute executes the request
func (a *FirewallAPIService) SetQuarantinedComponentViewAnonymousAccessExecute(r ApiSetQuarantinedComponentViewAnonymousAccessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.SetQuarantinedComponentViewAnonymousAccess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/malware-defense/quarantinedComponentView/configuration/anonymousAccess/{enabled}"
	localVarPath = strings.Replace(localVarPath, "{"+"enabled"+"}", url.PathEscape(parameterValueToString(r.enabled, "enabled")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
