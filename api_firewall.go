/*
Sonatype Lifecycle Public REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.182.0-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sonatypeiq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// FirewallAPIService FirewallAPI service
type FirewallAPIService service

type ApiAddRepositoryManagerRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	apiRepositoryManagerDTO *ApiRepositoryManagerDTO
}

func (r ApiAddRepositoryManagerRequest) ApiRepositoryManagerDTO(apiRepositoryManagerDTO ApiRepositoryManagerDTO) ApiAddRepositoryManagerRequest {
	r.apiRepositoryManagerDTO = &apiRepositoryManagerDTO
	return r
}

func (r ApiAddRepositoryManagerRequest) Execute() (*ApiRepositoryManagerDTO, *http.Response, error) {
	return r.ApiService.AddRepositoryManagerExecute(r)
}

/*
AddRepositoryManager Method for AddRepositoryManager

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddRepositoryManagerRequest
*/
func (a *FirewallAPIService) AddRepositoryManager(ctx context.Context) ApiAddRepositoryManagerRequest {
	return ApiAddRepositoryManagerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiRepositoryManagerDTO
func (a *FirewallAPIService) AddRepositoryManagerExecute(r ApiAddRepositoryManagerRequest) (*ApiRepositoryManagerDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryManagerDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.AddRepositoryManager")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/repositoryManagers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRepositoryManagerDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiRepositoryManagerDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConfigureRepositoriesRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	repositoryManagerId string
	apiRepositoryListDTO *ApiRepositoryListDTO
}

func (r ApiConfigureRepositoriesRequest) ApiRepositoryListDTO(apiRepositoryListDTO ApiRepositoryListDTO) ApiConfigureRepositoriesRequest {
	r.apiRepositoryListDTO = &apiRepositoryListDTO
	return r
}

func (r ApiConfigureRepositoriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigureRepositoriesExecute(r)
}

/*
ConfigureRepositories Method for ConfigureRepositories

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryManagerId
 @return ApiConfigureRepositoriesRequest
*/
func (a *FirewallAPIService) ConfigureRepositories(ctx context.Context, repositoryManagerId string) ApiConfigureRepositoriesRequest {
	return ApiConfigureRepositoriesRequest{
		ApiService: a,
		ctx: ctx,
		repositoryManagerId: repositoryManagerId,
	}
}

// Execute executes the request
func (a *FirewallAPIService) ConfigureRepositoriesExecute(r ApiConfigureRepositoriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.ConfigureRepositories")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/repositories/configuration/{repositoryManagerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryManagerId"+"}", url.PathEscape(parameterValueToString(r.repositoryManagerId, "repositoryManagerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRepositoryListDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRepositoryManagerRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	repositoryManagerId string
}

func (r ApiDeleteRepositoryManagerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRepositoryManagerExecute(r)
}

/*
DeleteRepositoryManager Method for DeleteRepositoryManager

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryManagerId
 @return ApiDeleteRepositoryManagerRequest
*/
func (a *FirewallAPIService) DeleteRepositoryManager(ctx context.Context, repositoryManagerId string) ApiDeleteRepositoryManagerRequest {
	return ApiDeleteRepositoryManagerRequest{
		ApiService: a,
		ctx: ctx,
		repositoryManagerId: repositoryManagerId,
	}
}

// Execute executes the request
func (a *FirewallAPIService) DeleteRepositoryManagerExecute(r ApiDeleteRepositoryManagerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.DeleteRepositoryManager")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/repositoryManagers/{repositoryManagerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryManagerId"+"}", url.PathEscape(parameterValueToString(r.repositoryManagerId, "repositoryManagerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEvaluateComponents1Request struct {
	ctx context.Context
	ApiService *FirewallAPIService
	repositoryManagerId string
	repositoryId string
	apiRepositoryComponentEvaluationRequestList *ApiRepositoryComponentEvaluationRequestList
}

func (r ApiEvaluateComponents1Request) ApiRepositoryComponentEvaluationRequestList(apiRepositoryComponentEvaluationRequestList ApiRepositoryComponentEvaluationRequestList) ApiEvaluateComponents1Request {
	r.apiRepositoryComponentEvaluationRequestList = &apiRepositoryComponentEvaluationRequestList
	return r
}

func (r ApiEvaluateComponents1Request) Execute() (*ApiRepositoryComponentEvaluationResultList, *http.Response, error) {
	return r.ApiService.EvaluateComponents1Execute(r)
}

/*
EvaluateComponents1 Method for EvaluateComponents1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryManagerId
 @param repositoryId
 @return ApiEvaluateComponents1Request
*/
func (a *FirewallAPIService) EvaluateComponents1(ctx context.Context, repositoryManagerId string, repositoryId string) ApiEvaluateComponents1Request {
	return ApiEvaluateComponents1Request{
		ApiService: a,
		ctx: ctx,
		repositoryManagerId: repositoryManagerId,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
//  @return ApiRepositoryComponentEvaluationResultList
func (a *FirewallAPIService) EvaluateComponents1Execute(r ApiEvaluateComponents1Request) (*ApiRepositoryComponentEvaluationResultList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryComponentEvaluationResultList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.EvaluateComponents1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/components/{repositoryManagerId}/{repositoryId}/evaluate"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryManagerId"+"}", url.PathEscape(parameterValueToString(r.repositoryManagerId, "repositoryManagerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryId"+"}", url.PathEscape(parameterValueToString(r.repositoryId, "repositoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRepositoryComponentEvaluationRequestList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiRepositoryComponentEvaluationResultList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfiguredRepositoriesRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	repositoryManagerId string
	sinceUtcTimestamp *int64
}

func (r ApiGetConfiguredRepositoriesRequest) SinceUtcTimestamp(sinceUtcTimestamp int64) ApiGetConfiguredRepositoriesRequest {
	r.sinceUtcTimestamp = &sinceUtcTimestamp
	return r
}

func (r ApiGetConfiguredRepositoriesRequest) Execute() (*ApiRepositoryListDTO, *http.Response, error) {
	return r.ApiService.GetConfiguredRepositoriesExecute(r)
}

/*
GetConfiguredRepositories Method for GetConfiguredRepositories

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryManagerId
 @return ApiGetConfiguredRepositoriesRequest
*/
func (a *FirewallAPIService) GetConfiguredRepositories(ctx context.Context, repositoryManagerId string) ApiGetConfiguredRepositoriesRequest {
	return ApiGetConfiguredRepositoriesRequest{
		ApiService: a,
		ctx: ctx,
		repositoryManagerId: repositoryManagerId,
	}
}

// Execute executes the request
//  @return ApiRepositoryListDTO
func (a *FirewallAPIService) GetConfiguredRepositoriesExecute(r ApiGetConfiguredRepositoriesRequest) (*ApiRepositoryListDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryListDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetConfiguredRepositories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/repositories/configuration/{repositoryManagerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryManagerId"+"}", url.PathEscape(parameterValueToString(r.repositoryManagerId, "repositoryManagerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sinceUtcTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sinceUtcTimestamp", r.sinceUtcTimestamp, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiRepositoryListDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallAutoUnquarantineConfigRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetFirewallAutoUnquarantineConfigRequest) Execute() ([]ApiFirewallReleaseQuarantineConfigDTO, *http.Response, error) {
	return r.ApiService.GetFirewallAutoUnquarantineConfigExecute(r)
}

/*
GetFirewallAutoUnquarantineConfig Method for GetFirewallAutoUnquarantineConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFirewallAutoUnquarantineConfigRequest
*/
func (a *FirewallAPIService) GetFirewallAutoUnquarantineConfig(ctx context.Context) ApiGetFirewallAutoUnquarantineConfigRequest {
	return ApiGetFirewallAutoUnquarantineConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApiFirewallReleaseQuarantineConfigDTO
func (a *FirewallAPIService) GetFirewallAutoUnquarantineConfigExecute(r ApiGetFirewallAutoUnquarantineConfigRequest) ([]ApiFirewallReleaseQuarantineConfigDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApiFirewallReleaseQuarantineConfigDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetFirewallAutoUnquarantineConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/releaseQuarantine/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []ApiFirewallReleaseQuarantineConfigDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallMetricsRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetFirewallMetricsRequest) Execute() (*map[string]ApiFirewallMetricsResultDTO, *http.Response, error) {
	return r.ApiService.GetFirewallMetricsExecute(r)
}

/*
GetFirewallMetrics Method for GetFirewallMetrics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFirewallMetricsRequest
*/
func (a *FirewallAPIService) GetFirewallMetrics(ctx context.Context) ApiGetFirewallMetricsRequest {
	return ApiGetFirewallMetricsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]ApiFirewallMetricsResultDTO
func (a *FirewallAPIService) GetFirewallMetricsExecute(r ApiGetFirewallMetricsRequest) (*map[string]ApiFirewallMetricsResultDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]ApiFirewallMetricsResultDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetFirewallMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/metrics/embedded"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v map[string]ApiFirewallMetricsResultDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallUnquarantineSummaryRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetFirewallUnquarantineSummaryRequest) Execute() (*ApiFirewallReleaseQuarantineSummaryDTO, *http.Response, error) {
	return r.ApiService.GetFirewallUnquarantineSummaryExecute(r)
}

/*
GetFirewallUnquarantineSummary Method for GetFirewallUnquarantineSummary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFirewallUnquarantineSummaryRequest
*/
func (a *FirewallAPIService) GetFirewallUnquarantineSummary(ctx context.Context) ApiGetFirewallUnquarantineSummaryRequest {
	return ApiGetFirewallUnquarantineSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiFirewallReleaseQuarantineSummaryDTO
func (a *FirewallAPIService) GetFirewallUnquarantineSummaryExecute(r ApiGetFirewallUnquarantineSummaryRequest) (*ApiFirewallReleaseQuarantineSummaryDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiFirewallReleaseQuarantineSummaryDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetFirewallUnquarantineSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/releaseQuarantine/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiFirewallReleaseQuarantineSummaryDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuarantineListRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	page *int32
	pageSize *int32
	policyId *[]string
	componentName *string
	sortBy *string
	asc *bool
}

func (r ApiGetQuarantineListRequest) Page(page int32) ApiGetQuarantineListRequest {
	r.page = &page
	return r
}

func (r ApiGetQuarantineListRequest) PageSize(pageSize int32) ApiGetQuarantineListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetQuarantineListRequest) PolicyId(policyId []string) ApiGetQuarantineListRequest {
	r.policyId = &policyId
	return r
}

func (r ApiGetQuarantineListRequest) ComponentName(componentName string) ApiGetQuarantineListRequest {
	r.componentName = &componentName
	return r
}

func (r ApiGetQuarantineListRequest) SortBy(sortBy string) ApiGetQuarantineListRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetQuarantineListRequest) Asc(asc bool) ApiGetQuarantineListRequest {
	r.asc = &asc
	return r
}

func (r ApiGetQuarantineListRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetQuarantineListExecute(r)
}

/*
GetQuarantineList Method for GetQuarantineList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQuarantineListRequest
*/
func (a *FirewallAPIService) GetQuarantineList(ctx context.Context) ApiGetQuarantineListRequest {
	return ApiGetQuarantineListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FirewallAPIService) GetQuarantineListExecute(r ApiGetQuarantineListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetQuarantineList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/components/quarantined"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 10
		r.pageSize = &defaultValue
	}
	if r.policyId != nil {
		t := *r.policyId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policyId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policyId", t, "form", "multi")
		}
	}
	if r.componentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentName", r.componentName, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	}
	if r.asc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asc", r.asc, "form", "")
	} else {
		var defaultValue bool = false
		r.asc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetQuarantineSummaryRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetQuarantineSummaryRequest) Execute() (*ApiFirewallQuarantineSummaryDTO, *http.Response, error) {
	return r.ApiService.GetQuarantineSummaryExecute(r)
}

/*
GetQuarantineSummary Method for GetQuarantineSummary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQuarantineSummaryRequest
*/
func (a *FirewallAPIService) GetQuarantineSummary(ctx context.Context) ApiGetQuarantineSummaryRequest {
	return ApiGetQuarantineSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiFirewallQuarantineSummaryDTO
func (a *FirewallAPIService) GetQuarantineSummaryExecute(r ApiGetQuarantineSummaryRequest) (*ApiFirewallQuarantineSummaryDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiFirewallQuarantineSummaryDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetQuarantineSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/quarantine/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiFirewallQuarantineSummaryDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuarantinedComponentViewAnonymousAccessRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetQuarantinedComponentViewAnonymousAccessRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetQuarantinedComponentViewAnonymousAccessExecute(r)
}

/*
GetQuarantinedComponentViewAnonymousAccess Method for GetQuarantinedComponentViewAnonymousAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQuarantinedComponentViewAnonymousAccessRequest
*/
func (a *FirewallAPIService) GetQuarantinedComponentViewAnonymousAccess(ctx context.Context) ApiGetQuarantinedComponentViewAnonymousAccessRequest {
	return ApiGetQuarantinedComponentViewAnonymousAccessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FirewallAPIService) GetQuarantinedComponentViewAnonymousAccessExecute(r ApiGetQuarantinedComponentViewAnonymousAccessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetQuarantinedComponentViewAnonymousAccess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/quarantinedComponentView/configuration/anonymousAccess"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRepositoryContainerRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetRepositoryContainerRequest) Execute() (*ApiRepositoryContainerDTO, *http.Response, error) {
	return r.ApiService.GetRepositoryContainerExecute(r)
}

/*
GetRepositoryContainer Method for GetRepositoryContainer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRepositoryContainerRequest
*/
func (a *FirewallAPIService) GetRepositoryContainer(ctx context.Context) ApiGetRepositoryContainerRequest {
	return ApiGetRepositoryContainerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiRepositoryContainerDTO
func (a *FirewallAPIService) GetRepositoryContainerExecute(r ApiGetRepositoryContainerRequest) (*ApiRepositoryContainerDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryContainerDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetRepositoryContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/repositoryContainer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiRepositoryContainerDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepositoryManagerRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	repositoryManagerId string
}

func (r ApiGetRepositoryManagerRequest) Execute() (*ApiRepositoryManagerDTO, *http.Response, error) {
	return r.ApiService.GetRepositoryManagerExecute(r)
}

/*
GetRepositoryManager Method for GetRepositoryManager

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryManagerId
 @return ApiGetRepositoryManagerRequest
*/
func (a *FirewallAPIService) GetRepositoryManager(ctx context.Context, repositoryManagerId string) ApiGetRepositoryManagerRequest {
	return ApiGetRepositoryManagerRequest{
		ApiService: a,
		ctx: ctx,
		repositoryManagerId: repositoryManagerId,
	}
}

// Execute executes the request
//  @return ApiRepositoryManagerDTO
func (a *FirewallAPIService) GetRepositoryManagerExecute(r ApiGetRepositoryManagerRequest) (*ApiRepositoryManagerDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryManagerDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetRepositoryManager")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/repositoryManagers/{repositoryManagerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryManagerId"+"}", url.PathEscape(parameterValueToString(r.repositoryManagerId, "repositoryManagerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiRepositoryManagerDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepositoryManagersRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
}

func (r ApiGetRepositoryManagersRequest) Execute() (*ApiRepositoryManagerListDTO, *http.Response, error) {
	return r.ApiService.GetRepositoryManagersExecute(r)
}

/*
GetRepositoryManagers Method for GetRepositoryManagers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRepositoryManagersRequest
*/
func (a *FirewallAPIService) GetRepositoryManagers(ctx context.Context) ApiGetRepositoryManagersRequest {
	return ApiGetRepositoryManagersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiRepositoryManagerListDTO
func (a *FirewallAPIService) GetRepositoryManagersExecute(r ApiGetRepositoryManagersRequest) (*ApiRepositoryManagerListDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiRepositoryManagerListDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetRepositoryManagers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/repositoryManagers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ApiRepositoryManagerListDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUnquarantineListRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	page *int32
	pageSize *int32
	policyId *string
	componentName *string
	sortBy *string
	asc *bool
}

func (r ApiGetUnquarantineListRequest) Page(page int32) ApiGetUnquarantineListRequest {
	r.page = &page
	return r
}

func (r ApiGetUnquarantineListRequest) PageSize(pageSize int32) ApiGetUnquarantineListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetUnquarantineListRequest) PolicyId(policyId string) ApiGetUnquarantineListRequest {
	r.policyId = &policyId
	return r
}

func (r ApiGetUnquarantineListRequest) ComponentName(componentName string) ApiGetUnquarantineListRequest {
	r.componentName = &componentName
	return r
}

func (r ApiGetUnquarantineListRequest) SortBy(sortBy string) ApiGetUnquarantineListRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetUnquarantineListRequest) Asc(asc bool) ApiGetUnquarantineListRequest {
	r.asc = &asc
	return r
}

func (r ApiGetUnquarantineListRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUnquarantineListExecute(r)
}

/*
GetUnquarantineList Method for GetUnquarantineList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUnquarantineListRequest
*/
func (a *FirewallAPIService) GetUnquarantineList(ctx context.Context) ApiGetUnquarantineListRequest {
	return ApiGetUnquarantineListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FirewallAPIService) GetUnquarantineListExecute(r ApiGetUnquarantineListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.GetUnquarantineList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/components/autoReleasedFromQuarantine"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 10
		r.pageSize = &defaultValue
	}
	if r.policyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyId", r.policyId, "form", "")
	}
	if r.componentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentName", r.componentName, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	}
	if r.asc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asc", r.asc, "form", "")
	} else {
		var defaultValue bool = true
		r.asc = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetFirewallAutoUnquarantineConfigRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	apiFirewallReleaseQuarantineConfigDTO *[]ApiFirewallReleaseQuarantineConfigDTO
}

func (r ApiSetFirewallAutoUnquarantineConfigRequest) ApiFirewallReleaseQuarantineConfigDTO(apiFirewallReleaseQuarantineConfigDTO []ApiFirewallReleaseQuarantineConfigDTO) ApiSetFirewallAutoUnquarantineConfigRequest {
	r.apiFirewallReleaseQuarantineConfigDTO = &apiFirewallReleaseQuarantineConfigDTO
	return r
}

func (r ApiSetFirewallAutoUnquarantineConfigRequest) Execute() ([]ApiFirewallReleaseQuarantineConfigDTO, *http.Response, error) {
	return r.ApiService.SetFirewallAutoUnquarantineConfigExecute(r)
}

/*
SetFirewallAutoUnquarantineConfig Method for SetFirewallAutoUnquarantineConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetFirewallAutoUnquarantineConfigRequest
*/
func (a *FirewallAPIService) SetFirewallAutoUnquarantineConfig(ctx context.Context) ApiSetFirewallAutoUnquarantineConfigRequest {
	return ApiSetFirewallAutoUnquarantineConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApiFirewallReleaseQuarantineConfigDTO
func (a *FirewallAPIService) SetFirewallAutoUnquarantineConfigExecute(r ApiSetFirewallAutoUnquarantineConfigRequest) ([]ApiFirewallReleaseQuarantineConfigDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApiFirewallReleaseQuarantineConfigDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.SetFirewallAutoUnquarantineConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/releaseQuarantine/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiFirewallReleaseQuarantineConfigDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []ApiFirewallReleaseQuarantineConfigDTO
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetQuarantinedComponentViewAnonymousAccessRequest struct {
	ctx context.Context
	ApiService *FirewallAPIService
	enabled bool
}

func (r ApiSetQuarantinedComponentViewAnonymousAccessRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetQuarantinedComponentViewAnonymousAccessExecute(r)
}

/*
SetQuarantinedComponentViewAnonymousAccess Method for SetQuarantinedComponentViewAnonymousAccess

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enabled
 @return ApiSetQuarantinedComponentViewAnonymousAccessRequest
*/
func (a *FirewallAPIService) SetQuarantinedComponentViewAnonymousAccess(ctx context.Context, enabled bool) ApiSetQuarantinedComponentViewAnonymousAccessRequest {
	return ApiSetQuarantinedComponentViewAnonymousAccessRequest{
		ApiService: a,
		ctx: ctx,
		enabled: enabled,
	}
}

// Execute executes the request
func (a *FirewallAPIService) SetQuarantinedComponentViewAnonymousAccessExecute(r ApiSetQuarantinedComponentViewAnonymousAccessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FirewallAPIService.SetQuarantinedComponentViewAnonymousAccess")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/firewall/quarantinedComponentView/configuration/anonymousAccess/{enabled}"
	localVarPath = strings.Replace(localVarPath, "{"+"enabled"+"}", url.PathEscape(parameterValueToString(r.enabled, "enabled")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
