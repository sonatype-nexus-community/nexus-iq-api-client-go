/*
Sonatype Lifecycle Public REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.195.0-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sonatypeiq

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PolicyWaiversAPIService PolicyWaiversAPI service
type PolicyWaiversAPIService service

type ApiAddPolicyWaiverByPolicyViolationIdRequest struct {
	ctx context.Context
	ApiService *PolicyWaiversAPIService
	ownerType string
	ownerId string
	policyViolationId string
	apiWaiverOptionsDTO *ApiWaiverOptionsDTO
}

// The request JSON can include the fields&lt;ol&gt;&lt;li&gt;comment (optional, to indicate the reason of the waiver) default value is null&lt;/li&gt;&lt;li&gt;applyToAllComponents (boolean, default &#39;false&#39;),deprecated in favor of matcherStrategy. If matcherStrategy is not set, &#39;true&#39; means this will apply the waiver to all components, &#39;false&#39; means this will apply to a specific component.&lt;/li&gt;&lt;li&gt;matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.&lt;/li&gt;&lt;li&gt;expiryTime (default null) to set the datetime when the waiver expires.&lt;/li&gt;&lt;/ol&gt;
func (r ApiAddPolicyWaiverByPolicyViolationIdRequest) ApiWaiverOptionsDTO(apiWaiverOptionsDTO ApiWaiverOptionsDTO) ApiAddPolicyWaiverByPolicyViolationIdRequest {
	r.apiWaiverOptionsDTO = &apiWaiverOptionsDTO
	return r
}

func (r ApiAddPolicyWaiverByPolicyViolationIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddPolicyWaiverByPolicyViolationIdExecute(r)
}

/*
AddPolicyWaiverByPolicyViolationId Method for AddPolicyWaiverByPolicyViolationId

Use this method to create a policy waiver.

Permissions required: Waive Policy Violations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Indicates the scope of the waiver. Possible values are application, organization, repository, repository_manager, repository_container.
 @param ownerId Enter the id for the ownerType provided above. E.g. applicationId if the ownerType is application.
 @param policyViolationId Enter the policyViolationId for the policy on which you want to create a waiver. Use the Policy Violation REST API or Reports REST API to obtain the policyViolationId.
 @return ApiAddPolicyWaiverByPolicyViolationIdRequest
*/
func (a *PolicyWaiversAPIService) AddPolicyWaiverByPolicyViolationId(ctx context.Context, ownerType string, ownerId string, policyViolationId string) ApiAddPolicyWaiverByPolicyViolationIdRequest {
	return ApiAddPolicyWaiverByPolicyViolationIdRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
		policyViolationId: policyViolationId,
	}
}

// Execute executes the request
func (a *PolicyWaiversAPIService) AddPolicyWaiverByPolicyViolationIdExecute(r ApiAddPolicyWaiverByPolicyViolationIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyWaiversAPIService.AddPolicyWaiverByPolicyViolationId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyWaivers/{ownerType}/{ownerId}/{policyViolationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyViolationId"+"}", url.PathEscape(parameterValueToString(r.policyViolationId, "policyViolationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiWaiverOptionsDTO == nil {
		return nil, reportError("apiWaiverOptionsDTO is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiWaiverOptionsDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest struct {
	ctx context.Context
	ApiService *PolicyWaiversAPIService
	ownerType string
	ownerId string
	scanId string
	componentIdentifier *ComponentIdentifier
	packageUrl *string
	hash *string
	apiWaiverOptionsDTO *ApiWaiverOptionsDTO
}

// Enter the component identifier of the transitive component on which you want to create a policy waiver.
func (r ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest) ComponentIdentifier(componentIdentifier ComponentIdentifier) ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest {
	r.componentIdentifier = &componentIdentifier
	return r
}

// Enter the package URL of the transitive component on which you want to create a policy waiver.
func (r ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest) PackageUrl(packageUrl string) ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest {
	r.packageUrl = &packageUrl
	return r
}

// Enter the hash of the transitive component on which you want to create a policy waiver.
func (r ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest) Hash(hash string) ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest {
	r.hash = &hash
	return r
}

// The request JSON can include the fields&lt;ol&gt;&lt;li&gt;comment (optional, to indicate the reason of the waiver) default value is null&lt;/li&gt;&lt;li&gt;applyToAllComponents (boolean, default &#39;false&#39;),deprecated in favor of matcherStrategy. If matcherStrategy is not set, &#39;true&#39; means this will apply the waiver to all components, &#39;false&#39; means this will apply to a specific component.&lt;/li&gt;&lt;li&gt;matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.&lt;/li&gt;&lt;li&gt;expiryTime (default null) to set the datetime when the waiver expires.&lt;/li&gt;&lt;/ol&gt;
func (r ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest) ApiWaiverOptionsDTO(apiWaiverOptionsDTO ApiWaiverOptionsDTO) ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest {
	r.apiWaiverOptionsDTO = &apiWaiverOptionsDTO
	return r
}

func (r ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddWaiverToTransitivePolicyViolationsByAppScanComponentExecute(r)
}

/*
AddWaiverToTransitivePolicyViolationsByAppScanComponent Method for AddWaiverToTransitivePolicyViolationsByAppScanComponent

Use this method to create a policy waiver on a transitive component detected during the specified scan. NOTE: Any one of the input parameters, i.e. component identifier, packageUrl or hash is required. If more than one is provided, the system will pick them in the order specified here.

Permissions required: Waive Policy Violations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Indicates the scope of the waiver that will be created.
 @param ownerId Enter the corresponding id for the ownerType specified above.
 @param scanId Enter the scanId (reportId) of the evaluation report that shows the transitive component.
 @return ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest
*/
func (a *PolicyWaiversAPIService) AddWaiverToTransitivePolicyViolationsByAppScanComponent(ctx context.Context, ownerType string, ownerId string, scanId string) ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest {
	return ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
		scanId: scanId,
	}
}

// Execute executes the request
func (a *PolicyWaiversAPIService) AddWaiverToTransitivePolicyViolationsByAppScanComponentExecute(r ApiAddWaiverToTransitivePolicyViolationsByAppScanComponentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyWaiversAPIService.AddWaiverToTransitivePolicyViolationsByAppScanComponent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyWaivers/transitive/{ownerType}/{ownerId}/{scanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scanId"+"}", url.PathEscape(parameterValueToString(r.scanId, "scanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.componentIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentIdentifier", r.componentIdentifier, "form", "")
	}
	if r.packageUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageUrl", r.packageUrl, "form", "")
	}
	if r.hash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hash", r.hash, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiWaiverOptionsDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest struct {
	ctx context.Context
	ApiService *PolicyWaiversAPIService
	ownerType string
	ownerId string
	stageId string
	apiWaiverOptionsDTO *ApiWaiverOptionsDTO
	componentIdentifier *ComponentIdentifier
	packageUrl *string
	hash *string
}

// &lt;ol&gt;&lt;li&gt;comment (optional, to indicate the reason of the waiver) default value is null&lt;/li&gt;&lt;li&gt;applyToAllComponents (boolean, default &#39;false&#39;),deprecated in favor of matcherStrategy. If matcherStrategy is not set, &#39;true&#39; means this will apply the waiver to all components, &#39;false&#39; means this will apply to a specific component.&lt;/li&gt;&lt;li&gt;matcherStrategy (enumeration, required) can have values DEFAULT, EXACT_COMPONENT, ALL_COMPONENTS, ALL_VERSIONS. DEFAULT will match all components if no hash is provided.&lt;/li&gt;&lt;li&gt;expiryTime (default null) to set the datetime when the waiver expires.&lt;/li&gt;&lt;/ol&gt;
func (r ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest) ApiWaiverOptionsDTO(apiWaiverOptionsDTO ApiWaiverOptionsDTO) ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest {
	r.apiWaiverOptionsDTO = &apiWaiverOptionsDTO
	return r
}

// Enter the component identifier and coordinates of the component for which you want to waive the transitive violations.
func (r ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest) ComponentIdentifier(componentIdentifier ComponentIdentifier) ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest {
	r.componentIdentifier = &componentIdentifier
	return r
}

// Enter the package URL of the component for which you want to waive the transitive violations.
func (r ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest) PackageUrl(packageUrl string) ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest {
	r.packageUrl = &packageUrl
	return r
}

// Enter the hash for the component for which you want to waive the transitive violations 
func (r ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest) Hash(hash string) ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest {
	r.hash = &hash
	return r
}

func (r ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddWaiverToTransitivePolicyViolationsByOwnerStageComponentExecute(r)
}

/*
AddWaiverToTransitivePolicyViolationsByOwnerStageComponent Method for AddWaiverToTransitivePolicyViolationsByOwnerStageComponent

Use this method to add a waiver for all transitive violations for a given component, detected in the latest scan at the stage specified.

Permissions required: Waive Policy Violations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Indicates the scope of the waiver that will be created.
 @param ownerId Enter the corresponding id for the ownerType specified above. E.g. applicationId for ownerType 'application' or organizationId for ownerType 'organization'.
 @param stageId Enter the stageId corresponding to the evaluation stage at which you want to create a waiver. Possible values are 'develop', 'source', 'build', 'stage-release', 'release' and 'operate'.
 @return ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest
*/
func (a *PolicyWaiversAPIService) AddWaiverToTransitivePolicyViolationsByOwnerStageComponent(ctx context.Context, ownerType string, ownerId string, stageId string) ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest {
	return ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
		stageId: stageId,
	}
}

// Execute executes the request
func (a *PolicyWaiversAPIService) AddWaiverToTransitivePolicyViolationsByOwnerStageComponentExecute(r ApiAddWaiverToTransitivePolicyViolationsByOwnerStageComponentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyWaiversAPIService.AddWaiverToTransitivePolicyViolationsByOwnerStageComponent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyWaivers/transitive/{ownerType}/{ownerId}/stages/{stageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stageId"+"}", url.PathEscape(parameterValueToString(r.stageId, "stageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiWaiverOptionsDTO == nil {
		return nil, reportError("apiWaiverOptionsDTO is required and must be specified")
	}

	if r.componentIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentIdentifier", r.componentIdentifier, "form", "")
	}
	if r.packageUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageUrl", r.packageUrl, "form", "")
	}
	if r.hash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hash", r.hash, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiWaiverOptionsDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePolicyWaiverRequest struct {
	ctx context.Context
	ApiService *PolicyWaiversAPIService
	ownerType string
	ownerId string
	policyWaiverId string
}

func (r ApiDeletePolicyWaiverRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePolicyWaiverExecute(r)
}

/*
DeletePolicyWaiver Method for DeletePolicyWaiver

Use this method to delete a waiver, specified by the policyWaiverId.

Permissions required: Waive Policy Violations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Enter the ownerType to specify the scope. A waiver corresponding to the policyWaiverId provided and within the scope specified will be deleted.
 @param ownerId Enter the corresponding id for the ownerType specified above.
 @param policyWaiverId Enter the policyWaiverId to be deleted.
 @return ApiDeletePolicyWaiverRequest
*/
func (a *PolicyWaiversAPIService) DeletePolicyWaiver(ctx context.Context, ownerType string, ownerId string, policyWaiverId string) ApiDeletePolicyWaiverRequest {
	return ApiDeletePolicyWaiverRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
		policyWaiverId: policyWaiverId,
	}
}

// Execute executes the request
func (a *PolicyWaiversAPIService) DeletePolicyWaiverExecute(r ApiDeletePolicyWaiverRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyWaiversAPIService.DeletePolicyWaiver")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyWaivers/{ownerType}/{ownerId}/{policyWaiverId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyWaiverId"+"}", url.PathEscape(parameterValueToString(r.policyWaiverId, "policyWaiverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPolicyWaiverRequest struct {
	ctx context.Context
	ApiService *PolicyWaiversAPIService
	ownerType string
	ownerId string
	policyWaiverId string
}

func (r ApiGetPolicyWaiverRequest) Execute() (*ApiPolicyWaiverDTO, *http.Response, error) {
	return r.ApiService.GetPolicyWaiverExecute(r)
}

/*
GetPolicyWaiver Method for GetPolicyWaiver

Use this method to retrieve waiver details for the waiverId specified.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Enter the ownerType to specify the scope. The response will contain the details for waivers within the scope.
 @param ownerId Enter the corresponding id for the ownerType specified above.
 @param policyWaiverId Enter the policyWaiverId for which you want to retrieve the waiver details.
 @return ApiGetPolicyWaiverRequest
*/
func (a *PolicyWaiversAPIService) GetPolicyWaiver(ctx context.Context, ownerType string, ownerId string, policyWaiverId string) ApiGetPolicyWaiverRequest {
	return ApiGetPolicyWaiverRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
		policyWaiverId: policyWaiverId,
	}
}

// Execute executes the request
//  @return ApiPolicyWaiverDTO
func (a *PolicyWaiversAPIService) GetPolicyWaiverExecute(r ApiGetPolicyWaiverRequest) (*ApiPolicyWaiverDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiPolicyWaiverDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyWaiversAPIService.GetPolicyWaiver")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyWaivers/{ownerType}/{ownerId}/{policyWaiverId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyWaiverId"+"}", url.PathEscape(parameterValueToString(r.policyWaiverId, "policyWaiverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyWaiversRequest struct {
	ctx context.Context
	ApiService *PolicyWaiversAPIService
	ownerType string
	ownerId string
}

func (r ApiGetPolicyWaiversRequest) Execute() ([]ApiPolicyWaiverDTO, *http.Response, error) {
	return r.ApiService.GetPolicyWaiversExecute(r)
}

/*
GetPolicyWaivers Method for GetPolicyWaivers

Use this method to retrieve waiver details for all policy waivers for the scope specified. You can specify the scope by using the parameters ownerType and ownerId.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Enter the ownerType to specify the scope. The response will contain waivers that are within the scope specified.
 @param ownerId Enter the corresponding id for the ownerType specified above.
 @return ApiGetPolicyWaiversRequest
*/
func (a *PolicyWaiversAPIService) GetPolicyWaivers(ctx context.Context, ownerType string, ownerId string) ApiGetPolicyWaiversRequest {
	return ApiGetPolicyWaiversRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
	}
}

// Execute executes the request
//  @return []ApiPolicyWaiverDTO
func (a *PolicyWaiversAPIService) GetPolicyWaiversExecute(r ApiGetPolicyWaiversRequest) ([]ApiPolicyWaiverDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApiPolicyWaiverDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyWaiversAPIService.GetPolicyWaivers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyWaivers/{ownerType}/{ownerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransitivePolicyWaiversByAppScanComponentRequest struct {
	ctx context.Context
	ApiService *PolicyWaiversAPIService
	ownerType string
	ownerId string
	scanId string
	componentIdentifier *ComponentIdentifier
	packageUrl *string
	hash *string
}

// Enter the component identifier for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
func (r ApiGetTransitivePolicyWaiversByAppScanComponentRequest) ComponentIdentifier(componentIdentifier ComponentIdentifier) ApiGetTransitivePolicyWaiversByAppScanComponentRequest {
	r.componentIdentifier = &componentIdentifier
	return r
}

// Enter the package URL for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
func (r ApiGetTransitivePolicyWaiversByAppScanComponentRequest) PackageUrl(packageUrl string) ApiGetTransitivePolicyWaiversByAppScanComponentRequest {
	r.packageUrl = &packageUrl
	return r
}

// Enter the hash for the component for which you want to retrieve the waivers on transitive policy violations, for the specified scanId.
func (r ApiGetTransitivePolicyWaiversByAppScanComponentRequest) Hash(hash string) ApiGetTransitivePolicyWaiversByAppScanComponentRequest {
	r.hash = &hash
	return r
}

func (r ApiGetTransitivePolicyWaiversByAppScanComponentRequest) Execute() (*ApiComponentPolicyWaiversDTO, *http.Response, error) {
	return r.ApiService.GetTransitivePolicyWaiversByAppScanComponentExecute(r)
}

/*
GetTransitivePolicyWaiversByAppScanComponent Method for GetTransitivePolicyWaiversByAppScanComponent

Use this method to retrieve all waivers on policy violations due to transitive dependencies for a specific component detected in a specific scan. Any one of the input parameters, i.e. componentIdentifier, packageUrl or hash is required. If more than one is provided, the system will pick them in the order specified here.

Permissions required: View IQ Elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Enter the ownerType to specify the scope. The response will contain the policy violations that are within the scope specified.
 @param ownerId Enter the corresponding id for the ownerType specified above.
 @param scanId Enter the scanId (reportId) of the scan for which you want to retrieve the waivers on transitive policy violations occurring due the dependencies of a component.
 @return ApiGetTransitivePolicyWaiversByAppScanComponentRequest
*/
func (a *PolicyWaiversAPIService) GetTransitivePolicyWaiversByAppScanComponent(ctx context.Context, ownerType string, ownerId string, scanId string) ApiGetTransitivePolicyWaiversByAppScanComponentRequest {
	return ApiGetTransitivePolicyWaiversByAppScanComponentRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
		scanId: scanId,
	}
}

// Execute executes the request
//  @return ApiComponentPolicyWaiversDTO
func (a *PolicyWaiversAPIService) GetTransitivePolicyWaiversByAppScanComponentExecute(r ApiGetTransitivePolicyWaiversByAppScanComponentRequest) (*ApiComponentPolicyWaiversDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiComponentPolicyWaiversDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyWaiversAPIService.GetTransitivePolicyWaiversByAppScanComponent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyWaivers/transitive/{ownerType}/{ownerId}/{scanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scanId"+"}", url.PathEscape(parameterValueToString(r.scanId, "scanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.componentIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentIdentifier", r.componentIdentifier, "form", "")
	}
	if r.packageUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packageUrl", r.packageUrl, "form", "")
	}
	if r.hash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hash", r.hash, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRequestPolicyWaiverRequest struct {
	ctx context.Context
	ApiService *PolicyWaiversAPIService
	policyViolationId string
	apiRequestPolicyWaiverDTO *ApiRequestPolicyWaiverDTO
}

// The request JSON should contain&lt;ol&gt;&lt;li&gt;comment (optional, default null) to indicate the waiver request reason&lt;/li&gt;&lt;li&gt;policyViolationLink (link to the policy violation page in the Lifecycle UI)&lt;/li&gt;&lt;li&gt;addWaiverLink (link to the Add Waiver page in the Lifecycle UI)&lt;/li&gt;&lt;/ol&gt;
func (r ApiRequestPolicyWaiverRequest) ApiRequestPolicyWaiverDTO(apiRequestPolicyWaiverDTO ApiRequestPolicyWaiverDTO) ApiRequestPolicyWaiverRequest {
	r.apiRequestPolicyWaiverDTO = &apiRequestPolicyWaiverDTO
	return r
}

func (r ApiRequestPolicyWaiverRequest) Execute() (*http.Response, error) {
	return r.ApiService.RequestPolicyWaiverExecute(r)
}

/*
RequestPolicyWaiver Method for RequestPolicyWaiver

Deprecated since IQ Server 1.192. Triggers a 'Waiver Request' webhook event. Deprecated because the webhook event is now integrated into the policy waiver request process. Please use `api/v2/policyWaiverRequests{ownerType}/policyViolation/{policyViolationId}` instead. Scheduled for removal in December 2025.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyViolationId Enter the policyViolationId for which you want to trigger the waiver request event.
 @return ApiRequestPolicyWaiverRequest

Deprecated
*/
func (a *PolicyWaiversAPIService) RequestPolicyWaiver(ctx context.Context, policyViolationId string) ApiRequestPolicyWaiverRequest {
	return ApiRequestPolicyWaiverRequest{
		ApiService: a,
		ctx: ctx,
		policyViolationId: policyViolationId,
	}
}

// Execute executes the request
// Deprecated
func (a *PolicyWaiversAPIService) RequestPolicyWaiverExecute(r ApiRequestPolicyWaiverRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyWaiversAPIService.RequestPolicyWaiver")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyWaivers/waiverRequests/{policyViolationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyViolationId"+"}", url.PathEscape(parameterValueToString(r.policyViolationId, "policyViolationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRequestPolicyWaiverDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdatePolicyWaiverRequest struct {
	ctx context.Context
	ApiService *PolicyWaiversAPIService
	ownerType string
	ownerId string
	policyWaiverId string
	apiWaiverOptionsDTO *ApiWaiverOptionsDTO
}

// Enter the policy waiver details to update. Note that updating &#x60;matcherStrategy&#x60; is currently unsupported.
func (r ApiUpdatePolicyWaiverRequest) ApiWaiverOptionsDTO(apiWaiverOptionsDTO ApiWaiverOptionsDTO) ApiUpdatePolicyWaiverRequest {
	r.apiWaiverOptionsDTO = &apiWaiverOptionsDTO
	return r
}

func (r ApiUpdatePolicyWaiverRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePolicyWaiverExecute(r)
}

/*
UpdatePolicyWaiver Method for UpdatePolicyWaiver

Use this method to update an existing policy waiver.

Permissions required: Waive Policy Violations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ownerType Indicates the scope of the policy waiver. Possible values are application, organization, repository, repository_manager, and repository_container.
 @param ownerId Enter the id for the `ownerType` provided above. E.g. `applicationId` if the `ownerType` is application.
 @param policyWaiverId Enter the id for the policy waiver.
 @return ApiUpdatePolicyWaiverRequest
*/
func (a *PolicyWaiversAPIService) UpdatePolicyWaiver(ctx context.Context, ownerType string, ownerId string, policyWaiverId string) ApiUpdatePolicyWaiverRequest {
	return ApiUpdatePolicyWaiverRequest{
		ApiService: a,
		ctx: ctx,
		ownerType: ownerType,
		ownerId: ownerId,
		policyWaiverId: policyWaiverId,
	}
}

// Execute executes the request
func (a *PolicyWaiversAPIService) UpdatePolicyWaiverExecute(r ApiUpdatePolicyWaiverRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyWaiversAPIService.UpdatePolicyWaiver")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/policyWaivers/{ownerType}/{ownerId}/{policyWaiverId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ownerType"+"}", url.PathEscape(parameterValueToString(r.ownerType, "ownerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownerId"+"}", url.PathEscape(parameterValueToString(r.ownerId, "ownerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyWaiverId"+"}", url.PathEscape(parameterValueToString(r.policyWaiverId, "policyWaiverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiWaiverOptionsDTO == nil {
		return nil, reportError("apiWaiverOptionsDTO is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiWaiverOptionsDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
